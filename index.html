<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craft Islands</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #7EC8E3;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: background-color 2s ease;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            z-index: 10;
        }
        #instructions {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            max-width: 600px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.8);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #interactionText {
            position: absolute;
            top: 55%;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        #zoneTitle {
            position: absolute;
            top: 15%;
            width: 100%;
            text-align: center;
            color: #fdf5e6;
            font-size: 38px;
            font-family: 'Georgia', serif;
            font-weight: bold;
            text-shadow: 2px 2px 8px black, 0 0 15px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        #zoneTitle.show {
            opacity: 1;
        }

        #loading {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            display: none;
            z-index: 20;
        }
        
        .loading-dots::after {
            content: '';
            animation: loadDots 1.5s steps(4, end) infinite;
        }
        
        @keyframes loadDots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            text-align: right;
            z-index: 5;
        }
        #topStats {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 15px;
            z-index: 5;
        }
        .hud-panel {
            background: rgba(100, 100, 100, 0.6);
            border: 2px solid gold;
            border-radius: 8px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px black;
        }
        #coinPanel {
            color: gold;
        }
        #itemsCounter {
            gap: 10px;
        }
        .item-icon {
            opacity: 0.3;
            filter: grayscale(100%);
            transition: all 0.5s ease;
        }
        .item-icon.collected {
            opacity: 1;
            filter: grayscale(0%);
        }
        #itemCard {
            position: absolute;
            top: 75%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.75);
            color: #fdf5e6;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #8b4513;
            text-align: center;
            font-family: 'Georgia', serif;
            z-index: 25;
            display: none;
            max-width: 450px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
        }
        #itemCard h3 {
            margin: 0 0 10px 0;
            color: #f39c12;
            font-size: 24px;
        }
        #itemCard p {
            margin: 0;
            font-size: 18px;
            line-height: 1.4;
        }
        #scorePanel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 5;
        }
        #lavaWarningText {
            position: absolute;
            top: 15%;
            width: 100%;
            text-align: center;
            color: #ffd700;
            font-size: 38px;
            font-family: 'Georgia', serif;
            font-weight: bold;
            text-shadow: 2px 2px 8px black, 0 0 15px rgba(255,215,0,0.8);
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        #lavaWarningText.show {
            opacity: 1;
        }
        #floatingDamage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 60px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black, 0 0 10px rgba(255,215,0,0.8);
            pointer-events: none;
            z-index: 15;
            opacity: 0;
        }
        @keyframes floatUpFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            12% { opacity: 1; transform: translate(-50%, -60%) scale(1.2); }
            60% { opacity: 1; transform: translate(-50%, -80%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(1); }
        }
        .float-anim {
            animation: floatUpFade 2.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
        }
        #weatherDisplay {
            background: rgba(0,0,0,0.5);
            border: 1px solid white;
            color: white;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 16px;
            display: inline-block;
            text-align: center;
            min-width: 25px;
        }

        /* Disclaimer */
        #disclaimer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            text-shadow: 1px 1px 3px black;
            pointer-events: none;
            z-index: 50;
            opacity: 1;
            transition: opacity 2s ease-in-out;
        }

        /* UI Modals */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }
        .modal-content {
            background: #fff;
            color: #333;
            padding: 30px;
            border-radius: 12px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-content h2 { margin-top: 0; text-align: center; }
        .close-btn {
            position: absolute;
            top: 15px; right: 20px;
            font-size: 24px; cursor: pointer;
            font-weight: bold; color: #888;
        }
        .close-btn:hover { color: #333; }

        /* Book UI */
        .verb-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        .verb-header { font-weight: bold; border-bottom: 2px solid #ccc; padding-bottom: 5px; }
        .verb-row { display: contents; }
        .verb-cell { padding: 5px 0; border-bottom: 1px solid #eee; }

        /* Test UI */
        .flashcard {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: opacity 0.5s;
        }
        .flashcard.correct { opacity: 0; pointer-events: none; height: 0; padding: 0; margin: 0; overflow: hidden; border: none; }
        .flashcard-es { font-weight: bold; width: 150px; font-size: 18px; color: #2c3e50; }
        .flashcard input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 120px;
            font-size: 16px;
        }
        .check-btn {
            background: #3498db; color: white; border: none; padding: 10px 20px;
            border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;
            margin-top: 20px; width: 100%;
        }
        .check-btn:hover { background: #2980b9; }
        .emoji-feedback { font-size: 20px; min-width: 30px; text-align: center; }

        /* Parchment Style */
        .parchment-box {
            background: #fdf5e6 url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" opacity="0.04"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.05" numOctaves="3" stitchTiles="stitch"/></filter><rect width="200" height="200" filter="url(%23n)"/></svg>');
            border: 8px solid #8b4513;
            border-radius: 8px;
            padding: 40px;
            max-width: 650px;
            color: #4a2f1d;
            font-family: 'Georgia', serif;
            font-size: 20px;
            line-height: 1.6;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 40px rgba(139,69,19,0.2);
            position: relative;
        }
        .parchment-box p {
            margin-bottom: 15px;
        }
        .parchment-box .close-btn {
            color: #8b4513;
            top: 15px;
            right: 20px;
        }
        .parchment-box .close-btn:hover {
            color: #3e2723;
        }
        .signature {
            text-align: right;
            margin-top: 30px;
            font-size: 24px;
            font-style: italic;
            font-family: 'Georgia', serif;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
    <div id="loading">Loading your adventure<span class="loading-dots"></span></div>
    <div id="topStats">
        <div class="hud-panel" id="coinPanel">ü™ô <span id="coinsVal">0</span> / 4</div>
        <div class="hud-panel" id="itemsCounter">
            <span class="item-icon" id="icon-canteen">üéí</span>
            <span class="item-icon" id="icon-machete">üó°Ô∏è</span>
            <span class="item-icon" id="icon-stick">ü¶Ø</span>
            <span class="item-icon" id="icon-lantern">üèÆ</span>
        </div>
    </div>
    <div id="hud">
        <div id="weatherDisplay">‚òÄÔ∏è</div>
    </div>
    
    <div id="interactionText">Interact</div>
    <div id="zoneTitle"></div>
    <div id="lavaWarningText">Oh no! You burned yourself with lava!</div>
    <div id="floatingDamage">-100</div>
    <div class="hud-panel" id="scorePanel">‚≠ê <span id="scoreVal">0</span></div>
    <div id="itemCard">
        <h3 id="itemCardTitle"></h3>
        <p id="itemCardDesc"></p>
    </div>
    <div id="disclaimer">Application created with Gemini AI by Eduardo Ruiz (@ejruizgarcia), licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</div>

    <div id="blocker">
        <div id="instructions">
            <h1 id="gameTitle" style="font-size: 42px; margin-bottom: 10px; color: #e69138; text-shadow: 2px 2px 5px black;">Craft Islands</h1>
            <p id="mainText" style="font-size: 18px; line-height: 1.5;">Welcome to the interactive game of the mysterious islands.</p>
            <p id="controlsText" style="font-size: 16px; color: #ccc;">Controls:<br>
            W, A, S, D to move | Click to interact<br>
            Hold R to sprint | Space to jump<br>
            CTRL + S = Screenshot | CTRL + M = Mute</p>
        </div>
    </div>
    <div id="crosshair"></div>

    <!-- Story Modal -->
    <div id="storyModal" class="modal-overlay">
        <div class="parchment-box">
            <span class="close-btn" onclick="closeStory()">√ó</span>
            <p>Welcome to the Craft Islands. In this adventure you will find four islands, and on each island many objects and places. Keep taking notes of everything you see in your notebook. You must visit the places you find and write down the weather, because you will need everything for the final writing task. You can also optionally look for hidden mysterious objects around the islands to earn extra points.</p>
            <p>Finally, you will have to collect the four gold coins to be able to leave. Where are the coins? Guess it, I will give you a hint... you will have to go inside...</p>
            <div class="signature">Good luck.<br>Captain Ruiz.</div>
        </div>
    </div>

    <!-- Book Modal -->
    <div id="bookModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-btn" onclick="closeBook()">√ó</span>
            <h2 id="bookTitle">Irregular Verbs Book</h2>
            <div class="verb-grid" id="bookGrid"></div>
        </div>
    </div>

    <!-- Test Modal -->
    <div id="testModal" class="modal-overlay">
        <div class="modal-content" style="background: #eef2f5;">
            <span class="close-btn" onclick="closeTest()">√ó</span>
            <h2>Irregular Verbs Test</h2>
            <p style="text-align:center; color:#555;">Complete the 3 forms for each verb. You need 80% to pass.</p>
            <div id="testCardsContainer"></div>
            <button id="checkTestBtn" class="check-btn" onclick="checkTest()">Check Answers</button>
            <button id="continueTestBtn" class="check-btn" style="display:none; background:#27ae60;" onclick="finishTest()">Continue</button>
            <p id="testResult" style="text-align:center; font-weight:bold; margin-top:15px; font-size:18px;"></p>
        </div>
    </div>

    <!-- Congrats Modal -->
    <div id="congratsModal" class="modal-overlay">
        <div class="modal-content" style="text-align: center;">
            <h2 style="color: #f39c12; font-size: 32px;">üåü Excellent Work! üåü</h2>
            <p style="font-size: 18px; margin: 20px 0;">You have passed the test and unlocked the door.</p>
            <p style="font-size: 16px; color: #555;">Collect all 4 gold coins to complete your adventure.</p>
            <button class="check-btn" style="width:auto;" onclick="closeCongrats()">Continue</button>
        </div>
    </div>

    <!-- Endgame Modal -->
    <div id="endgameModal" class="modal-overlay">
        <div class="modal-content" style="text-align: center;">
            <h2 style="color: #27ae60; font-size: 36px;">üèÜ CONGRATULATIONS! üèÜ</h2>
            <p style="font-size: 18px; margin: 20px 0;">You have mastered the irregular verbs and collected all 4 coins!</p>
            <p style="font-size: 16px;">Please enter your surname to claim these islands:</p>
            <input type="text" id="surnameInput" style="padding:10px; font-size:18px; width:200px; margin-bottom:20px; border:2px solid #ccc; border-radius:5px;"><br>
            <button class="check-btn" style="width:auto; background:#27ae60;" onclick="claimIslands()">Claim Islands</button>
        </div>
    </div>

    <!-- All Items Found Modal -->
    <div id="allItemsModal" class="modal-overlay">
        <div class="modal-content" style="text-align: center;">
            <h2 style="color: #2980b9; font-size: 32px;">üéí Awesome Discovery! üèÆ</h2>
            <p style="font-size: 18px; margin: 20px 0;">Congratulations! You have found all four mysterious objects hidden across the islands.</p>
            <p style="font-size: 16px; color: #555;">Keep exploring and remember to take notes for your final task.</p>
            <button class="check-btn" style="width:auto; background:#2980b9;" onclick="closeAllItemsModal()">Continue</button>
        </div>
    </div>

    <!-- Final Diploma Modal -->
    <div id="diplomaModal" class="modal-overlay">
        <div class="parchment-box" style="text-align: center;">
            <p>Congratulations, you have managed to finish the game.</p>
            <p>As a gift, from this moment on, the islands are renamed:</p>
            <p><span id="finalIslandsName" style="font-size: 40px; font-weight: bold; color: #8b4513; display: block; margin: 15px 0;"></span></p>
            <p style="font-size: 24px; font-weight: bold; color: #27ae60; margin-bottom: 20px;">Final Score: <span id="finalScoreDisplay"></span> points</p>
            <div class="signature">
                Signed Captain Ruiz<br>
                <span id="diplomaDate"></span>
            </div>
            <div style="margin-top:30px; display: flex; justify-content: center; gap: 15px;">
                <button id="screenshotBtn" class="check-btn" style="width:auto; margin-top:0; background:#2980b9; color:#fff;" onclick="takeScreenshot()">üì∑ Capture Diploma</button>
                <button id="closeDiplomaBtn" class="check-btn" style="width:auto; margin-top:0; background:#8b4513; color:#fdf5e6; border: 2px solid #5a2a0a;" onclick="location.reload()">CLOSE</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Verb Data
        const VERB_BLOCKS = {
            1: [
                {es: "ser/estar", v1: "be", v2: "was/were", v3: "been"},
                {es: "golpear/vencer", v1: "beat", v2: "beat", v3: "beaten"},
                {es: "llegar a ser", v1: "become", v2: "became", v3: "become"},
                {es: "empezar", v1: "begin", v2: "began", v3: "begun"},
                {es: "morder", v1: "bite", v2: "bit", v3: "bitten"},
                {es: "soplar", v1: "blow", v2: "blew", v3: "blown"},
                {es: "romper", v1: "break", v2: "broke", v3: "broken"},
                {es: "traer", v1: "bring", v2: "brought", v3: "brought"},
                {es: "construir", v1: "build", v2: "built", v3: "built"},
                {es: "quemar", v1: "burn", v2: "burnt", v3: "burnt"},
                {es: "comprar", v1: "buy", v2: "bought", v3: "bought"},
                {es: "poder", v1: "can", v2: "could", v3: "-"},
                {es: "atrapar", v1: "catch", v2: "caught", v3: "caught"},
                {es: "elegir", v1: "choose", v2: "chose", v3: "chosen"},
                {es: "venir", v1: "come", v2: "came", v3: "come"},
                {es: "costar", v1: "cost", v2: "cost", v3: "cost"},
                {es: "cortar", v1: "cut", v2: "cut", v3: "cut"},
                {es: "hacer", v1: "do", v2: "did", v3: "done"},
                {es: "dibujar", v1: "draw", v2: "drew", v3: "drawn"},
                {es: "so√±ar", v1: "dream", v2: "dreamt", v3: "dreamt"},
                {es: "beber", v1: "drink", v2: "drank", v3: "drunk"},
                {es: "conducir", v1: "drive", v2: "drove", v3: "driven"}
            ],
            2: [
                {es: "comer", v1: "eat", v2: "ate", v3: "eaten"},
                {es: "caer", v1: "fall", v2: "fell", v3: "fallen"},
                {es: "alimentar", v1: "feed", v2: "fed", v3: "fed"},
                {es: "sentir", v1: "feel", v2: "felt", v3: "felt"},
                {es: "luchar", v1: "fight", v2: "fought", v3: "fought"},
                {es: "encontrar", v1: "find", v2: "found", v3: "found"},
                {es: "volar", v1: "fly", v2: "flew", v3: "flown"},
                {es: "olvidar", v1: "forget", v2: "forgot", v3: "forgotten"},
                {es: "perdonar", v1: "forgive", v2: "forgave", v3: "forgiven"},
                {es: "congelar", v1: "freeze", v2: "froze", v3: "frozen"},
                {es: "obtener", v1: "get", v2: "got", v3: "got"},
                {es: "dar", v1: "give", v2: "gave", v3: "given"},
                {es: "ir", v1: "go", v2: "went", v3: "gone"},
                {es: "crecer/cultivar", v1: "grow", v2: "grew", v3: "grown"},
                {es: "colgar", v1: "hang", v2: "hung", v3: "hung"},
                {es: "tener/haber", v1: "have", v2: "had", v3: "had"},
                {es: "o√≠r", v1: "hear", v2: "heard", v3: "heard"},
                {es: "esconder", v1: "hide", v2: "hid", v3: "hidden"},
                {es: "golpear", v1: "hit", v2: "hit", v3: "hit"},
                {es: "sostener", v1: "hold", v2: "held", v3: "held"},
                {es: "herir/doler", v1: "hurt", v2: "hurt", v3: "hurt"},
                {es: "guardar", v1: "keep", v2: "kept", v3: "kept"}
            ],
            3: [
                {es: "saber", v1: "know", v2: "knew", v3: "known"},
                {es: "liderar", v1: "lead", v2: "led", v3: "led"},
                {es: "aprender", v1: "learn", v2: "learnt", v3: "learnt"},
                {es: "dejar/irse", v1: "leave", v2: "left", v3: "left"},
                {es: "prestar", v1: "lend", v2: "lent", v3: "lent"},
                {es: "permitir", v1: "let", v2: "let", v3: "let"},
                {es: "mentir/yacer", v1: "lie", v2: "lay", v3: "lain"},
                {es: "perder", v1: "lose", v2: "lost", v3: "lost"},
                {es: "hacer/fabricar", v1: "make", v2: "made", v3: "made"},
                {es: "conocer", v1: "meet", v2: "met", v3: "met"},
                {es: "pagar", v1: "pay", v2: "paid", v3: "paid"},
                {es: "poner", v1: "put", v2: "put", v3: "put"},
                {es: "leer", v1: "read", v2: "read", v3: "read"},
                {es: "montar", v1: "ride", v2: "rode", v3: "ridden"},
                {es: "sonar", v1: "ring", v2: "rang", v3: "rung"},
                {es: "correr", v1: "run", v2: "ran", v3: "run"},
                {es: "decir", v1: "say", v2: "said", v3: "said"},
                {es: "ver", v1: "see", v2: "saw", v3: "seen"},
                {es: "vender", v1: "sell", v2: "sold", v3: "sold"},
                {es: "enviar", v1: "send", v2: "sent", v3: "sent"},
                {es: "establecer", v1: "set", v2: "set", v3: "set"},
                {es: "sacudir", v1: "shake", v2: "shook", v3: "shaken"}
            ],
            4: [
                {es: "brillar", v1: "shine", v2: "shone", v3: "shone"},
                {es: "mostrar", v1: "show", v2: "showed", v3: "shown"},
                {es: "cerrar", v1: "shut", v2: "shut", v3: "shut"},
                {es: "cantar", v1: "sing", v2: "sang", v3: "sung"},
                {es: "sentarse", v1: "sit", v2: "sat", v3: "sat"},
                {es: "dormir", v1: "sleep", v2: "slept", v3: "slept"},
                {es: "hablar", v1: "speak", v2: "spoke", v3: "spoken"},
                {es: "deletrear", v1: "spell", v2: "spelt", v3: "spelt"},
                {es: "gastar tiempo", v1: "spend", v2: "spent", v3: "spent"},
                {es: "estar de pie", v1: "stand", v2: "stood", v3: "stood"},
                {es: "robar", v1: "steal", v2: "stole", v3: "stolen"},
                {es: "nadar", v1: "swim", v2: "swam", v3: "swum"},
                {es: "tomar/llevar", v1: "take", v2: "took", v3: "taken"},
                {es: "ense√±ar", v1: "teach", v2: "taught", v3: "taught"},
                {es: "contar", v1: "tell", v2: "told", v3: "told"},
                {es: "pensar", v1: "think", v2: "thought", v3: "thought"},
                {es: "lanzar", v1: "throw", v2: "threw", v3: "thrown"},
                {es: "entender", v1: "understand", v2: "understood", v3: "understood"},
                {es: "despertar", v1: "wake", v2: "woke", v3: "woken"},
                {es: "llevar puesto", v1: "wear", v2: "wore", v3: "worn"},
                {es: "ganar", v1: "win", v2: "won", v3: "won"},
                {es: "escribir", v1: "write", v2: "wrote", v3: "written"}
            ]
        };

        const weatherTypes = ['SUNNY', 'CLOUDY', 'RAINY', 'STORMY', 'WINDY', 'FOGGY', 'SNOWY'];

        let timeOfDay = 60; 
        let weatherIndex = 0;
        let currentWeather = weatherTypes[weatherIndex];
        let weatherTimer = 10; 
        let manualWeather = false;
        let globalUniforms = { uTime: { value: 0 }, uWind: { value: 0 }, uSnow: { value: 0 }, uRain: { value: 0 } };
        let targetWind = 0, targetSnow = 0, targetRain = 0, targetFogDensity = 0.002;
        let lightningFlash = 0;

        let camera, scene, renderer, controls;
        let blocksMap = new Map(); 
        let instancedMeshes = {}; 
        let dirLight, ambientLight;

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isRunning = false, canJump = false, wasSwimming = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        const raycaster = new THREE.Raycaster();
        const interactables = [];
        let collectibleHalos = [];
        let coins = 0;
        let activeTestZone = null;
        let activeTestVerbs = [];
        let isUIOpen = false;
        let isFirstStart = true;
        let hideCardTimeout;
        let zoneTitleTimeout;
        let collectedItemsCount = 0;
        let gameScore = 0;
        let hasBurnedFirstTime = false;
        let lavaDamageCooldown = 0;
        let isGodView = false;
        let isTransitioningToGodView = false;
        let isTransitioningFromGodView = false;
        let transitionTime = 0;
        let startTransitionPos = new THREE.Vector3();
        let startTransitionPitch = 0;
        let startTransitionYaw = 0;
        let savedPos = new THREE.Vector3();
        let savedPitch = 0;
        let savedYaw = 0;
        let targetGodYaw = 0;
        let godViewLevel = 0;
        let targetGodAltitude = 300;

        const collectiblesData = {
            canteen: { title: "Old Rucksack", desc: "An old leather backpack left behind by a previous explorer.", iconId: "icon-canteen" },
            machete: { title: "Rusty Machete", desc: "Its blade is dull, but it can still clear a path through thick jungle vines.", iconId: "icon-machete" },
            stick: { title: "Climbing Stick", desc: "A sturdy wooden stick, perfectly balanced to help navigate steep mountain trails.", iconId: "icon-stick" },
            lantern: { title: "Paper Lantern", desc: "A bright orange paper lantern, perfect for lighting up dark, treacherous volcanic paths.", iconId: "icon-lantern" }
        };

        const zones = {
            1: { name: "Hut", center: new THREE.Vector3(335, 10, 135), radius: 4.5, door: null, locked: false, completed: false, inside: false, titleText: "Welcome to the shelter of the mountain island" },
            2: { name: "Shipwreck", center: new THREE.Vector3(175, 4, 108), radius: 3.5, door: null, locked: false, completed: false, inside: false, titleText: "Welcome to the shipwreck of the volcano island" },
            3: { name: "Temple", center: new THREE.Vector3(100, 24, 350), radius: 6.5, door: null, locked: false, completed: false, inside: false, titleText: "Welcome to the Hindu temple of the jungle island" },
            4: { name: "Pyramid", center: new THREE.Vector3(300, 5, 300), radius: 13, door: null, locked: false, completed: false, inside: false, titleText: "Welcome to the pyramid of the desert island" }
        };

        function updateScore() {
            document.getElementById('scoreVal').innerText = gameScore;
        }

        function applyLavaDamage() {
            gameScore -= 100;
            updateScore();
            
            const damageEl = document.getElementById('floatingDamage');
            const warningEl = document.getElementById('lavaWarningText');

            if (!hasBurnedFirstTime) {
                hasBurnedFirstTime = true;
                warningEl.classList.add('show');
                
                setTimeout(() => {
                    warningEl.classList.remove('show');
                    setTimeout(() => {
                        damageEl.classList.remove('float-anim');
                        void damageEl.offsetWidth; 
                        damageEl.classList.add('float-anim');
                    }, 1000);
                }, 3000);
            } else {
                damageEl.classList.remove('float-anim');
                void damageEl.offsetWidth; 
                damageEl.classList.add('float-anim');
            }
        }

        const TYPES = {
            AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, SNOW: 4, SAND: 5, LAVA: 6, WATER: 7, 
            WOOD: 8, LEAVES: 9, CACTUS: 10, FLOWER: 11, STEM: 12, TORCH: 13, PLANK: 14, GOLD: 15
        };

        const INVISIBLE_BARRIER = 99; 

        function createTexture(hex, type) {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const color = new THREE.Color(hex);
            const hsl = {};
            color.getHSL(hsl);

            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    let l = hsl.l;
                    if (type === 'wood') {
                        l += (Math.random() - 0.5) * 0.1;
                        if (x % 4 === 0 || x % 5 === 0) l -= 0.15; 
                    } else if (type === 'plank') {
                        l += (Math.random() - 0.5) * 0.05;
                        if (y % 4 === 0 || x % 16 === 0) l -= 0.15; 
                    } else if (type === 'stone') {
                        l += (Math.random() - 0.5) * 0.15;
                        if (Math.random() < 0.05) l -= 0.25; 
                    } else if (type === 'leaves') {
                        l += (Math.random() - 0.5) * 0.2;
                    } else if (type === 'lava') {
                        l = (Math.random() > 0.5) ? 0.5 : 0.6;
                        color.setHex((Math.random() > 0.8) ? 0xffaa00 : 0xff4500);
                        color.getHSL(hsl);
                    } else {
                        l += (Math.random() - 0.5) * 0.1;
                    }
                    ctx.fillStyle = new THREE.Color().setHSL(hsl.h, hsl.s, l).getStyle();
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createGrassSide() {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    let isGrass = y < 4 || (y < 7 && Math.random() > 0.5);
                    let c = new THREE.Color(isGrass ? 0x478c2e : 0x5e4026);
                    let hsl = {};
                    c.getHSL(hsl);
                    hsl.l += (Math.random() - 0.5) * 0.1;
                    ctx.fillStyle = c.setHSL(hsl.h, hsl.s, hsl.l).getStyle();
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const texDirt = createTexture(0x5e4026, 'dirt');
        const texStone = createTexture(0x777777, 'stone');
        const texSnow = createTexture(0xffffff, 'snow');
        const texSand = createTexture(0xd2b48c, 'sand');
        const texWood = createTexture(0x5c4033, 'wood');
        const texLeaves = createTexture(0x228b22, 'leaves');
        const texCactus = createTexture(0x2e8b57, 'cactus');
        const texPlank = createTexture(0x8b5a2b, 'plank');
        const texGold = createTexture(0xffd700, 'gold');
        const texLava = createTexture(0xff4500, 'lava');
        const texWater = createTexture(0x1ca3ec, 'water');

        function patchMaterial(material, isLeaves, isGround) {
            material.onBeforeCompile = function (shader) {
                shader.uniforms.uTime = globalUniforms.uTime;
                shader.uniforms.uWind = globalUniforms.uWind;
                shader.uniforms.uSnow = globalUniforms.uSnow;
                
                let vertexPrefix = 'uniform float uTime;\nuniform float uWind;\nvarying vec3 vWorldNormal;\nvarying vec3 vWorldPos;\n';
                let fragmentPrefix = 'uniform float uSnow;\nvarying vec3 vWorldNormal;\nvarying vec3 vWorldPos;\n';
                
                shader.vertexShader = vertexPrefix + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <worldpos_vertex>',
                    `#include <worldpos_vertex>
                     #ifndef USE_INSTANCING
                     vWorldNormal = normalize((modelMatrix * vec4(objectNormal, 0.0)).xyz);
                     vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                     #else
                     vWorldNormal = normalize((instanceMatrix * vec4(objectNormal, 0.0)).xyz);
                     vWorldPos = (instanceMatrix * vec4(position, 1.0)).xyz;
                     #endif`
                );
                
                if (isLeaves) {
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `#include <begin_vertex>
                         #ifdef USE_INSTANCING
                         float randomOffset = fract(sin(instanceMatrix[3][0] * 12.9898 + instanceMatrix[3][2] * 78.233) * 43758.5453);
                         float sway = sin(uTime * (3.0 + randomOffset) + randomOffset * 10.0) * uWind * 0.2;
                         float swayZ = cos(uTime * (2.5 + randomOffset) + randomOffset * 10.0) * uWind * 0.15;
                         transformed.x += sway;
                         transformed.z += swayZ;
                         #endif`
                    );
                }
                
                shader.fragmentShader = fragmentPrefix + shader.fragmentShader;
                
                if (isGround) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <dithering_fragment>',
                        `#include <dithering_fragment>
                         float indoor = 0.0;
                         if (vWorldPos.x > 328.0 && vWorldPos.x < 342.0 && vWorldPos.z > 128.0 && vWorldPos.z < 142.0 && vWorldPos.y < 20.0) indoor = 1.0;
                         if (vWorldPos.x > 171.0 && vWorldPos.x < 179.0 && vWorldPos.z > 103.0 && vWorldPos.z < 112.0 && vWorldPos.y < 7.0) indoor = 1.0;
                         if (length(vWorldPos.xz - vec2(100.0, 350.0)) < 8.5 && vWorldPos.y >= 24.0 && vWorldPos.y < 64.0) indoor = 1.0;
                         if (vWorldPos.x > 284.0 && vWorldPos.x < 316.0 && vWorldPos.z > 284.0 && vWorldPos.z < 316.0 && vWorldPos.y < 22.0) indoor = 1.0;
                         float snowMix = uSnow * smoothstep(0.5, 0.9, vWorldNormal.y) * (1.0 - indoor);
                         gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.95, 0.95, 0.98), snowMix);`
                    );
                }
                material.userData.shader = shader;
            };
        }

        const waterMaterial = new THREE.MeshPhysicalMaterial({ map: texWater, transparent: true, opacity: 0.7 });
        waterMaterial.onBeforeCompile = function (shader) {
            shader.uniforms.uTime = globalUniforms.uTime;
            shader.uniforms.uRain = globalUniforms.uRain;
            waterMaterial.userData.shader = shader;
            shader.vertexShader = 'uniform float uTime;\nuniform float uRain;\n' + shader.vertexShader;
            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `vec3 transformed = vec3( position );
                 #ifdef USE_INSTANCING
                 float wave = sin(uTime * 2.0 + instanceMatrix[3][0] * 0.5 + instanceMatrix[3][2] * 0.5) * 0.15;
                 float ripple = sin(instanceMatrix[3][0] * 10.0 + instanceMatrix[3][2] * 10.0 - uTime * 15.0) * uRain * 0.05;
                 transformed.y += wave + ripple;
                 #endif`
            );
        };

        const matGrass = [
            new THREE.MeshLambertMaterial({ map: createGrassSide() }), 
            new THREE.MeshLambertMaterial({ map: createGrassSide() }), 
            new THREE.MeshLambertMaterial({ map: createTexture(0x478c2e, 'grass') }), 
            new THREE.MeshLambertMaterial({ map: texDirt }), 
            new THREE.MeshLambertMaterial({ map: createGrassSide() }), 
            new THREE.MeshLambertMaterial({ map: createGrassSide() })  
        ];
        matGrass.forEach(m => patchMaterial(m, false, true));

        const matDirt = new THREE.MeshLambertMaterial({ map: texDirt }); patchMaterial(matDirt, false, true);
        const matStone = new THREE.MeshLambertMaterial({ map: texStone }); patchMaterial(matStone, false, true);
        const matSnow = new THREE.MeshLambertMaterial({ map: texSnow }); patchMaterial(matSnow, false, true);
        const matSand = new THREE.MeshLambertMaterial({ map: texSand }); patchMaterial(matSand, false, true);
        const matWood = new THREE.MeshLambertMaterial({ map: texWood }); patchMaterial(matWood, false, true);
        const matLeaves = new THREE.MeshLambertMaterial({ map: texLeaves, transparent: true, opacity: 0.95 }); patchMaterial(matLeaves, true, true);
        const matPlank = new THREE.MeshLambertMaterial({ map: texPlank }); patchMaterial(matPlank, false, true);

        const MATERIALS = {
            [TYPES.GRASS]: matGrass,
            [TYPES.DIRT]: matDirt,
            [TYPES.STONE]: matStone,
            [TYPES.SNOW]: matSnow,
            [TYPES.SAND]: matSand,
            [TYPES.LAVA]: new THREE.MeshBasicMaterial({ map: texLava }), 
            [TYPES.WATER]: waterMaterial,
            [TYPES.WOOD]: matWood,
            [TYPES.LEAVES]: matLeaves,
            [TYPES.CACTUS]: new THREE.MeshLambertMaterial({ map: texCactus }),
            [TYPES.FLOWER]: new THREE.MeshLambertMaterial({ color: 0xffffff }), 
            [TYPES.STEM]: new THREE.MeshLambertMaterial({ color: 0x32cd32 }),
            [TYPES.TORCH]: new THREE.MeshBasicMaterial({ color: 0xffcc00 }),
            [TYPES.PLANK]: matPlank,
            [TYPES.GOLD]: new THREE.MeshLambertMaterial({ map: texGold })
        };

        const blockData = {};
        for(let key in TYPES) blockData[TYPES[key]] = [];

        const waterSet = new Set();
        let cloudParticles, rainParticles, snowParticles, lightningMesh, volcanoParticles;
        let dynamicLights = [];
        let fireParticleSystems = [];

        const MAX_SPLASH_PARTICLES = 600;
        let splashParticles, splashPositions;
        let splashVelocities = [], splashLifetimes = [];

        let audioCtx;
        let rainGain, windGain;
        let isMuted = false;

        window.showBlocker = function(type) {
            const blocker = document.getElementById('blocker');
            const title = document.getElementById('gameTitle');
            const main = document.getElementById('mainText');
            const controlsText = document.getElementById('controlsText');

            blocker.style.display = 'flex';

            if (type === 'user') {
                title.style.display = 'block';
                title.innerText = 'Game Paused';
                main.innerText = 'Click to continue your adventure.';
                main.style.fontSize = '18px';
                main.style.fontWeight = 'normal';
                controlsText.style.display = 'block';
            } else if (type === 'technical') {
                title.style.display = 'none';
                main.innerText = 'Click to resume the game';
                main.style.fontSize = '28px';
                main.style.fontWeight = 'bold';
                controlsText.style.display = 'none';
            }
        };

        window.closeStory = function() {
            document.getElementById('storyModal').style.display = 'none';
            isUIOpen = false;
            controls.lock();
            if (!audioCtx) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        };

        window.closeBook = function() {
            document.getElementById('bookModal').style.display = 'none';
            isUIOpen = false;
            window.showBlocker('technical');
        };
        
        window.closeTest = function() {
            document.getElementById('testModal').style.display = 'none';
            if (document.getElementById('congratsModal').style.display !== 'flex') {
                isUIOpen = false;
                window.showBlocker('technical');
            }
        };
        
        window.closeCongrats = function() {
            document.getElementById('congratsModal').style.display = 'none';
            if(coins === 4) {
                document.getElementById('endgameModal').style.display = 'flex';
                document.exitPointerLock();
            } else {
                isUIOpen = false;
                window.showBlocker('technical');
            }
        };
        
        window.claimIslands = function() {
            const surname = document.getElementById('surnameInput').value.trim();
            if(surname) {
                document.getElementById('endgameModal').style.display = 'none';
                document.getElementById('gameTitle').innerText = `${surname} Islands`;
                
                document.getElementById('finalIslandsName').innerText = `${surname.toUpperCase()} ISLANDS`;
                
                document.getElementById('finalScoreDisplay').innerText = gameScore;

                const today = new Date();
                const dateStr = today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                document.getElementById('diplomaDate').innerText = dateStr;
                
                document.getElementById('diplomaModal').style.display = 'flex';
            }
        };

        window.closeAllItemsModal = function() {
            document.getElementById('allItemsModal').style.display = 'none';
            isUIOpen = false;
            window.showBlocker('technical');
        };

        window.takeScreenshot = function() {
            const btn = document.getElementById('screenshotBtn');
            const closeBtn = document.getElementById('closeDiplomaBtn');
            btn.style.display = 'none';
            closeBtn.style.display = 'none';
            
            renderer.render(scene, camera);
            
            setTimeout(() => {
                html2canvas(document.body).then(canvas => {
                    const link = document.createElement('a');
                    link.download = 'diploma_craft_islands.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    btn.style.display = '';
                    closeBtn.style.display = '';
                });
            }, 100);
        };

        window.finishTest = function() {
            document.getElementById('testModal').style.display = 'none';
            const zone = zones[activeTestZone];
            zone.completed = true;
            zone.locked = false;
            zone.door.targetRot = zone.door.openRot;
            coins++;
            document.getElementById('coinsVal').innerText = coins;
            document.getElementById('congratsModal').style.display = 'flex';
        };

        window.checkTest = function() {
            let correctCount = 0;
            const matchInput = (inputVal, targetVal) => {
                const val = inputVal.toLowerCase().trim();
                if(targetVal.includes('/')) {
                    const parts = targetVal.split('/');
                    return val === targetVal || parts.includes(val);
                }
                return val === targetVal || (targetVal === '-' && val === '');
            };

            for(let i=0; i<10; i++) {
                const verb = activeTestVerbs[i];
                const card = document.getElementById(`fc-${i}`);
                if(card.classList.contains('correct')) {
                    correctCount++;
                    continue;
                }

                const i1 = document.getElementById(`v1-${i}`).value;
                const i2 = document.getElementById(`v2-${i}`).value;
                const i3 = document.getElementById(`v3-${i}`).value;

                const r1 = matchInput(i1, verb.v1);
                const r2 = matchInput(i2, verb.v2);
                const r3 = matchInput(i3, verb.v3);

                document.getElementById(`e1-${i}`).innerText = r1 ? "‚úÖ" : "‚ùå";
                document.getElementById(`e2-${i}`).innerText = r2 ? "‚úÖ" : "‚ùå";
                document.getElementById(`e3-${i}`).innerText = r3 ? "‚úÖ" : "‚ùå";

                if(r1 && r2 && r3) {
                    card.classList.add('correct');
                    correctCount++;
                }
            }

            const resP = document.getElementById('testResult');
            if(correctCount >= 8) {
                gameScore += (correctCount * 100);
                updateScore();
                resP.style.color = 'green';
                resP.innerText = `Test Passed! ${correctCount}/10 correct. You earned ${correctCount * 100} points.`;
                document.getElementById('checkTestBtn').style.display = 'none';
                document.getElementById('continueTestBtn').style.display = 'block';
            } else {
                resP.style.color = 'red';
                resP.innerText = `You need 8/10 to pass. Score: ${correctCount}/10. Fix your mistakes and try again!`;
            }
        };

        function toggleMute() {
            isMuted = !isMuted;
        }

        init();

        function init() {
            document.getElementById('loading').style.display = 'block';
            setTimeout(() => {
                setupScene();
                generateWorld();
                setupWeatherSystems();
                initSplashParticles(); 
                finalizeInit();
                document.getElementById('loading').style.display = 'none';
                
                setTimeout(() => {
                    const disclaimer = document.getElementById('disclaimer');
                    if (disclaimer) {
                        disclaimer.style.opacity = '0';
                    }
                }, 5000);

            }, 100);
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x7EC8E3); 
            scene.fog = new THREE.FogExp2(0x7EC8E3, 0.002); 

            ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(200, 300, 200);
            scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 6, 95); 
            camera.lookAt(45, 6, 95);

            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            instructions.addEventListener('click', function (event) { 
                if (isFirstStart) {
                    isFirstStart = false;
                    document.getElementById('blocker').style.display = 'none';
                    isUIOpen = true;
                    document.getElementById('storyModal').style.display = 'flex';
                } else {
                    controls.lock();
                    if (!audioCtx) initAudio();
                    if (audioCtx.state === 'suspended') audioCtx.resume();
                }
            });
            controls.addEventListener('lock', function () { blocker.style.display = 'none'; });
            controls.addEventListener('unlock', function () { 
                if (!isUIOpen) window.showBlocker('user'); 
            });
            scene.add(controls.getObject());

            const onKeyDown = function (event) {
                if (event.ctrlKey && (event.code === 'KeyM' || event.key === 'm' || event.key === 'M')) {
                    toggleMute();
                    event.preventDefault();
                    return;
                }

                if (event.altKey && (event.code === 'KeyD' || event.key === 'd' || event.key === 'D')) {
                    event.preventDefault();
                    if (timeOfDay < 240) {
                        timeOfDay = 250; 
                    } else {
                        timeOfDay = 60;  
                    }
                    return;
                }

                if (event.altKey && (event.code === 'KeyW' || event.key === 'w' || event.key === 'W')) {
                    event.preventDefault();
                    manualWeather = true;
                    weatherIndex = (weatherIndex + 1) % weatherTypes.length;
                    currentWeather = weatherTypes[weatherIndex];
                    return;
                }

                if (event.altKey && (event.code === 'KeyT' || event.key === 't' || event.key === 'T')) {
                    event.preventDefault();
                    
                    const tpDestinations = [
                        { x: 335, z: 145 },
                        { x: 175, z: 125 },
                        { x: 100, z: 335 },
                        { x: 300, z: 325 }
                    ];
                    
                    const playerPos = controls.getObject().position;
                    let currentIdx = 0;
                    let minDist = Infinity;
                    
                    for(let i=0; i<tpDestinations.length; i++) {
                        let dist = Math.hypot(playerPos.x - tpDestinations[i].x, playerPos.z - tpDestinations[i].z);
                        if(dist < minDist) {
                            minDist = dist;
                            currentIdx = i;
                        }
                    }
                    
                    let nextIdx = (currentIdx + 1) % tpDestinations.length;
                    let dest = tpDestinations[nextIdx];
                    
                    let rawHighestY = getFloorHeight(dest.x, dest.z, 50);
                    controls.getObject().position.set(dest.x, (rawHighestY - 0.5) + 1.6, dest.z);
                    
                    camera.rotation.set(0, 0, 0);
                    controls.getObject().rotation.x = 0;
                    controls.getObject().rotation.z = 0;
                    velocity.set(0, 0, 0);
                    
                    isGodView = false;
                    isTransitioningToGodView = false;
                    isTransitioningFromGodView = false;
                    return;
                }

                if (event.altKey && (event.code === 'KeyF' || event.key === 'f' || event.key === 'F')) {
                    event.preventDefault();
                    
                    const findDestinations = [
                        { x: 295, z: 312 }, 
                        { x: 100, z: 366 },  
                        { x: 297, z: 103 }, 
                        { x: 152, z: 100 }  
                    ];
                    
                    const playerPos = controls.getObject().position;
                    let currentIdx = 0;
                    let minDist = Infinity;
                    
                    for(let i=0; i<findDestinations.length; i++) {
                        let dist = Math.hypot(playerPos.x - findDestinations[i].x, playerPos.z - findDestinations[i].z);
                        if(dist < minDist) {
                            minDist = dist;
                            currentIdx = i;
                        }
                    }
                    
                    let nextIdx = (currentIdx + 1) % findDestinations.length;
                    let dest = findDestinations[nextIdx];
                    
                    let rawHighestY = getFloorHeight(dest.x, dest.z, 60);
                    controls.getObject().position.set(dest.x, (rawHighestY - 0.5) + 1.6, dest.z);
                    
                    camera.rotation.set(0, 0, 0);
                    controls.getObject().rotation.x = 0;
                    controls.getObject().rotation.z = 0;
                    velocity.set(0, 0, 0);
                    
                    isGodView = false;
                    isTransitioningToGodView = false;
                    isTransitioningFromGodView = false;
                    return;
                }

                if (event.altKey && (event.code === 'KeyG' || event.key === 'g' || event.key === 'G')) {
                    event.preventDefault();
                    if (isTransitioningFromGodView || isTransitioningToGodView) return;

                    if (!isGodView) {
                        savedPos.copy(controls.getObject().position);
                        savedPitch = camera.rotation.x;
                        savedYaw = controls.getObject().rotation.y;
                        
                        isTransitioningToGodView = true;
                        transitionTime = 0;
                        startTransitionPos.copy(controls.getObject().position);
                        startTransitionPitch = camera.rotation.x;
                        startTransitionYaw = controls.getObject().rotation.y;
                        
                        godViewLevel = 1;
                        targetGodAltitude = 300;

                        let diff = 0 - startTransitionYaw;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        targetGodYaw = startTransitionYaw + diff;
                        
                        velocity.set(0,0,0);
                    } else {
                        if (godViewLevel === 1) {
                            godViewLevel = 2;
                            targetGodAltitude = 200;
                            isTransitioningToGodView = true;
                            transitionTime = 0;
                            startTransitionPos.copy(controls.getObject().position);
                            startTransitionPitch = camera.rotation.x;
                            startTransitionYaw = controls.getObject().rotation.y;
                            targetGodYaw = startTransitionYaw;
                            velocity.set(0,0,0);
                        } else if (godViewLevel === 2) {
                            godViewLevel = 3;
                            targetGodAltitude = 100;
                            isTransitioningToGodView = true;
                            transitionTime = 0;
                            startTransitionPos.copy(controls.getObject().position);
                            startTransitionPitch = camera.rotation.x;
                            startTransitionYaw = controls.getObject().rotation.y;
                            targetGodYaw = startTransitionYaw;
                            velocity.set(0,0,0);
                        } else {
                            godViewLevel = 0;
                            isGodView = false;
                            isTransitioningFromGodView = true;
                            transitionTime = 0;
                            startTransitionPos.copy(controls.getObject().position);
                            startTransitionPitch = camera.rotation.x;
                            startTransitionYaw = controls.getObject().rotation.y;
                            
                            let diff = savedYaw - startTransitionYaw;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            while (diff > Math.PI) diff -= Math.PI * 2;
                            savedYaw = startTransitionYaw + diff;
                            
                            velocity.set(0,0,0);
                        }
                    }
                    return;
                }

                if (event.altKey && (event.code === 'KeyP' || event.key === 'p' || event.key === 'P')) {
                    if (document.getElementById('testModal').style.display === 'flex' && document.getElementById('continueTestBtn').style.display === 'none') {
                        event.preventDefault();
                        
                        for(let i=0; i<10; i++) {
                            const card = document.getElementById(`fc-${i}`);
                            if(card) card.classList.add('correct');
                        }
                        
                        gameScore += 1000;
                        updateScore();
                        const resP = document.getElementById('testResult');
                        resP.style.color = 'green';
                        resP.innerText = `Test Passed (Shortcut)! 10/10 correct. You earned 1000 points.`;
                        document.getElementById('checkTestBtn').style.display = 'none';
                        document.getElementById('continueTestBtn').style.display = 'block';
                        return;
                    }
                }

                if (event.ctrlKey && (event.code === 'KeyS' || event.key === 's' || event.key === 'S')) {
                    event.preventDefault();
                    renderer.render(scene, camera);
                    const link = document.createElement('a');
                    link.download = 'captura_craft_islands.png';
                    link.href = renderer.domElement.toDataURL('image/png');
                    link.click();
                    return;
                }

                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'KeyR': isRunning = true; break; 
                    case 'Space':
                        if (canJump === true) velocity.y += 11; 
                        canJump = false;
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                    case 'KeyR': isRunning = false; break; 
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
        }

        function onMouseClick(event) {
            if(!controls.isLocked) return;

            if (isGodView) {
                let targetX = controls.getObject().position.x;
                let targetZ = controls.getObject().position.z;
                let targetY;

                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const allMeshes = Object.values(instancedMeshes);
                const intersects = raycaster.intersectObjects(allMeshes, false);

                if (intersects.length > 0) {
                    targetX = intersects[0].point.x;
                    targetZ = intersects[0].point.z;
                    targetY = intersects[0].point.y + 1.6;
                } else {
                    let rawFloorY = getFloorHeight(targetX, targetZ, 300);
                    targetY = (rawFloorY - 0.5) + 1.6;
                }

                const oceanLevel = 2.0;
                const waterSurfaceY = oceanLevel + 0.2; 
                if (targetY < waterSurfaceY + 1.6 && (targetY - 1.6) < oceanLevel && !isInsideStructure(targetX, targetZ, oceanLevel)) {
                    targetY = waterSurfaceY;
                }

                savedPos.set(targetX, targetY, targetZ);
                savedPitch = 0; 
                savedYaw = controls.getObject().rotation.y; 
                
                godViewLevel = 0;
                isGodView = false;
                isTransitioningFromGodView = true;
                transitionTime = 0;
                startTransitionPos.copy(controls.getObject().position);
                startTransitionPitch = camera.rotation.x;
                startTransitionYaw = controls.getObject().rotation.y;
                
                let diff = savedYaw - startTransitionYaw;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                savedYaw = startTransitionYaw + diff;
                
                velocity.set(0,0,0);
                return;
            }

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(interactables, false);
            if (intersects.length > 0 && intersects[0].distance < 6) {
                handleInteraction(intersects[0].object);
            }
        }

        function handleInteraction(obj) {
            const data = obj.userData;
            if(data.type === 'door') {
                const zone = zones[data.zone];
                if(zone.locked) {
                    
                } else {
                    zone.door.targetRot = zone.door.targetRot === zone.door.baseRot ? zone.door.openRot : zone.door.baseRot;
                }
            } else if (data.type === 'book') {
                openBook(data.zone);
            } else if (data.type === 'lever') {
                openTest(data.zone);
            } else if (data.type === 'collectible') {
                collectItem(obj);
            }
        }

        function collectItem(mesh) {
            const id = mesh.userData.id;
            const data = collectiblesData[id];
            
            document.getElementById(data.iconId).classList.add('collected');
            document.getElementById('itemCardTitle').innerText = data.title;
            document.getElementById('itemCardDesc').innerText = data.desc;
            
            const card = document.getElementById('itemCard');
            card.style.display = 'block';
            
            clearTimeout(hideCardTimeout);
            
            scene.remove(mesh);
            const index = interactables.indexOf(mesh);
            if(index > -1) interactables.splice(index, 1);

            collectedItemsCount++;
            gameScore += 200;
            updateScore();

            if (collectedItemsCount === 4) {
                hideCardTimeout = setTimeout(() => {
                    card.style.display = 'none';
                    isUIOpen = true;
                    document.exitPointerLock();
                    document.getElementById('blocker').style.display = 'none';
                    document.getElementById('allItemsModal').style.display = 'flex';
                }, 2500);
            } else {
                hideCardTimeout = setTimeout(() => {
                    card.style.display = 'none';
                }, 6000);
            }
        }

        function openBook(zoneId) {
            isUIOpen = true;
            document.exitPointerLock();
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('bookModal').style.display = 'flex';
            document.getElementById('bookTitle').innerText = `Block ${zoneId} Verbs`;
            
            const grid = document.getElementById('bookGrid');
            grid.innerHTML = `
                <div class="verb-header">Meaning (ES)</div><div class="verb-header">Infinitive</div><div class="verb-header">Past Simple</div><div class="verb-header">Participle</div>
            `;
            VERB_BLOCKS[zoneId].forEach(v => {
                grid.innerHTML += `
                    <div class="verb-cell">${v.es}</div>
                    <div class="verb-cell">${v.v1}</div>
                    <div class="verb-cell">${v.v2}</div>
                    <div class="verb-cell">${v.v3}</div>
                `;
            });
        }

        function openTest(zoneId) {
            const zone = zones[zoneId];
            if(zone.completed) return;
            
            isUIOpen = true;
            document.exitPointerLock();
            document.getElementById('blocker').style.display = 'none';
            activeTestZone = zoneId;
            document.getElementById('testModal').style.display = 'flex';
            document.getElementById('testResult').innerText = "";
            document.getElementById('checkTestBtn').style.display = 'block';
            document.getElementById('continueTestBtn').style.display = 'none';
            
            const allVerbs = [...VERB_BLOCKS[zoneId]];
            activeTestVerbs = allVerbs.sort(() => 0.5 - Math.random()).slice(0, 10);
            
            const container = document.getElementById('testCardsContainer');
            container.innerHTML = "";
            activeTestVerbs.forEach((v, i) => {
                container.innerHTML += `
                    <div class="flashcard" id="fc-${i}">
                        <div class="flashcard-es">${v.es}</div>
                        <div><input type="text" id="v1-${i}" placeholder="Infinitive" autocomplete="off"> <span class="emoji-feedback" id="e1-${i}"></span></div>
                        <div><input type="text" id="v2-${i}" placeholder="Past" autocomplete="off"> <span class="emoji-feedback" id="e2-${i}"></span></div>
                        <div><input type="text" id="v3-${i}" placeholder="Participle" autocomplete="off"> <span class="emoji-feedback" id="e3-${i}"></span></div>
                    </div>
                `;
            });
        }

        function createInteractable(geo, mat, x, y, z, userData) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            mesh.updateMatrixWorld(true);
            mesh.geometry.computeBoundingBox();
            const box = new THREE.Box3();
            box.copy(mesh.geometry.boundingBox).applyMatrix4(mesh.matrixWorld);
            userData.box = box;
            
            mesh.userData = userData;
            scene.add(mesh);
            interactables.push(mesh);
            return mesh;
        }

        function createComplexInteractable(group, x, y, z, userData) {
            group.position.set(x, y, z);
            scene.add(group);
            
            group.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(group);
            
            const w = box.max.x - box.min.x;
            const h = box.max.y - box.min.y;
            const d = box.max.z - box.min.z;
            
            const hitBox = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d),
                new THREE.MeshBasicMaterial({visible: false})
            );
            
            const center = new THREE.Vector3();
            box.getCenter(center);
            hitBox.position.copy(center);
            
            userData.box = box;
            hitBox.userData = userData;
            scene.add(hitBox);
            interactables.push(hitBox);
            
            return hitBox;
        }

        function createControlledDoor(x, y, z, width, height, pivotOffsetX, pivotOffsetZ, rotationY, swingAngle, zoneId, tiltX = 0) {
            const baseGroup = new THREE.Group();
            baseGroup.position.set(x, y, z); 
            baseGroup.rotation.x = tiltX;
            scene.add(baseGroup);

            const doorGroup = new THREE.Group();
            baseGroup.add(doorGroup);
            
            const doorGeo = new THREE.BoxGeometry(width, height, 0.3); 
            const doorMat = new THREE.MeshLambertMaterial({ map: texPlank });
            const doorMesh = new THREE.Mesh(doorGeo, doorMat);
            
            doorMesh.position.set(pivotOffsetX, height / 2, pivotOffsetZ); 
            doorMesh.userData = { type: 'door', zone: zoneId };
            interactables.push(doorMesh);

            doorGroup.add(doorMesh);
            doorGroup.rotation.y = rotationY;
            
            const doorObj = {
                group: doorGroup,
                baseRot: rotationY,
                openRot: rotationY + swingAngle,
                targetRot: rotationY,
                x: x + pivotOffsetX,
                y: y,
                z: z + pivotOffsetZ,
                width: width,
                height: height,
                tiltX: tiltX
            };
            zones[zoneId].door = doorObj;
            return doorObj;
        }

        function createCollectibleMesh(id, x, y, z) {
            let mesh;
            let trueGround = y - 0.5;

            if (id === 'canteen') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.0, 0.8), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}));
                
                let body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.3), new THREE.MeshLambertMaterial({color: 0x8b5a2b}));
                body.position.y = 0;
                
                let flap = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.1, 0.32), new THREE.MeshLambertMaterial({color: 0x6b4226}));
                flap.position.set(0, 0.3, 0);
                
                let pocket = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.25, 0.15), new THREE.MeshLambertMaterial({color: 0x6b4226}));
                pocket.position.set(0, -0.1, 0.18);
                
                let leftPocket = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.2), new THREE.MeshLambertMaterial({color: 0x6b4226}));
                leftPocket.position.set(-0.28, -0.05, 0);
                
                let rightPocket = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.2), new THREE.MeshLambertMaterial({color: 0x6b4226}));
                rightPocket.position.set(0.28, -0.05, 0);
                
                let bedroll = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.6, 8), new THREE.MeshLambertMaterial({color: 0x3a5f2b}));
                bedroll.rotation.z = Math.PI / 2;
                bedroll.position.set(0, 0.45, 0);
                
                let strap1 = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.32, 0.05), new THREE.MeshLambertMaterial({color: 0x3e2723}));
                strap1.position.set(-0.15, 0.45, 0);
                
                let strap2 = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.32, 0.05), new THREE.MeshLambertMaterial({color: 0x3e2723}));
                strap2.position.set(0.15, 0.45, 0);

                mesh.add(body);
                mesh.add(flap);
                mesh.add(pocket);
                mesh.add(leftPocket);
                mesh.add(rightPocket);
                mesh.add(bedroll);
                mesh.add(strap1);
                mesh.add(strap2);
                
                mesh.position.set(x, trueGround + 0.35, z);
                mesh.rotation.x = -Math.PI / 12;
                mesh.rotation.y = Math.PI / 4;
            } else if (id === 'machete') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.8, 0.4), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}));
                let handle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05), new THREE.MeshLambertMaterial({color: 0x5c4033}));
                handle.position.y = -0.2;
                let blade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.6, 0.1), new THREE.MeshLambertMaterial({color: 0x777777}));
                blade.position.y = 0.2;
                mesh.add(handle);
                mesh.add(blade);
                mesh.position.set(x, trueGround + 0.2, z);
                mesh.rotation.x = Math.PI / 2;
                mesh.rotation.z = Math.PI / 6;
            } else if (id === 'stick') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.6, 0.4), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}));
                let stickModel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8), new THREE.MeshLambertMaterial({color: 0x6b4226}));
                stickModel.rotation.x = Math.PI / 8;
                stickModel.rotation.z = Math.PI / 8;
                mesh.add(stickModel);
                mesh.position.set(x, trueGround + 0.60, z);
            } else if (id === 'lantern') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.4), new THREE.MeshBasicMaterial({transparent: true, opacity: 0}));
                let base = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.05, 8), new THREE.MeshLambertMaterial({color: 0x222222}));
                base.position.y = -0.15;
                let body = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.3, 8), new THREE.MeshLambertMaterial({color: 0xff6600}));
                body.position.y = 0.025;
                let top = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.05, 8), new THREE.MeshLambertMaterial({color: 0x222222}));
                top.position.y = 0.2;
                mesh.add(base);
                mesh.add(body);
                mesh.add(top);
                mesh.position.set(x, trueGround + 0.175, z);
            }

            let haloGeo = new THREE.SphereGeometry(0.5, 16, 16);
            let haloMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            let haloMesh = new THREE.Mesh(haloGeo, haloMat);
            mesh.add(haloMesh);

            let itemLight = new THREE.PointLight(0xffffff, 2.0, 10);
            mesh.add(itemLight);

            collectibleHalos.push({ halo: haloMesh, light: itemLight });

            mesh.userData = { type: 'collectible', id: id };
            scene.add(mesh);
            interactables.push(mesh);
        }

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const bufferSize = audioCtx.sampleRate * 2;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const rainNoise = audioCtx.createBufferSource();
            rainNoise.buffer = noiseBuffer;
            rainNoise.loop = true;
            const rainFilter = audioCtx.createBiquadFilter();
            rainFilter.type = 'lowpass'; 
            rainFilter.frequency.value = 1500;
            rainGain = audioCtx.createGain();
            rainGain.gain.value = 0;
            rainNoise.connect(rainFilter).connect(rainGain).connect(audioCtx.destination);
            rainNoise.start();

            const windNoise = audioCtx.createBufferSource();
            windNoise.buffer = noiseBuffer;
            windNoise.loop = true;
            const windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'lowpass';
            windFilter.frequency.value = 400;
            windGain = audioCtx.createGain();
            windGain.gain.value = 0;
            windNoise.connect(windFilter).connect(windGain).connect(audioCtx.destination);
            windNoise.start();

            const windLFO = audioCtx.createOscillator();
            windLFO.type = 'sine';
            windLFO.frequency.value = 0.3;
            const windLFOGain = audioCtx.createGain();
            windLFOGain.gain.value = 250;
            windLFO.connect(windLFOGain).connect(windFilter.frequency);
            windLFO.start();
        }

        function playThunder(muffled) {
            if (!audioCtx || isMuted) return;
            const now = audioCtx.currentTime;

            const bufferSize = audioCtx.sampleRate * 4;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer;

            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.value = muffled ? 100 : 300;

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0, now);
            noiseGain.gain.linearRampToValueAtTime(muffled ? 0.5 : 1.5, now + 0.1);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 3.5);

            noise.connect(noiseFilter).connect(noiseGain).connect(audioCtx.destination);
            noise.start(now);
        }

        function finalizeInit() {
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupWeatherSystems() {
            const cloudGeo = new THREE.BoxGeometry(60, 8, 60);
            const cloudMat = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: 0.0});
            cloudParticles = new THREE.InstancedMesh(cloudGeo, cloudMat, 50);
            const dummy = new THREE.Object3D();
            for(let i=0; i<50; i++) {
                dummy.position.set((Math.random()-0.5)*800 + 200, 120 + Math.random()*15, (Math.random()-0.5)*800 + 200);
                dummy.updateMatrix();
                cloudParticles.setMatrixAt(i, dummy.matrix);
            }
            scene.add(cloudParticles);

            const rainGeo = new THREE.BufferGeometry();
            const rainPos = new Float32Array(3000 * 3);
            for(let i=0; i<3000; i++) {
                rainPos[i*3] = (Math.random() - 0.5) * 80;
                rainPos[i*3+1] = Math.random() * 80;
                rainPos[i*3+2] = (Math.random() - 0.5) * 80;
            }
            rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
            const rainMat = new THREE.PointsMaterial({color: 0xaaaaee, size: 0.5, transparent: true, opacity: 0});
            rainParticles = new THREE.Points(rainGeo, rainMat);
            scene.add(rainParticles);

            const snowGeo = new THREE.BufferGeometry();
            const snowPos = new Float32Array(3000 * 3);
            for(let i=0; i<3000; i++) {
                snowPos[i*3] = (Math.random() - 0.5) * 80;
                snowPos[i*3+1] = Math.random() * 80;
                snowPos[i*3+2] = (Math.random() - 0.5) * 80;
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            const snowMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.8, transparent: true, opacity: 0});
            snowParticles = new THREE.Points(snowGeo, snowMat);
            scene.add(snowParticles);

            const lightGeo = new THREE.CylinderGeometry(0.5, 0.1, 100, 4);
            const lightMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0});
            lightningMesh = new THREE.Mesh(lightGeo, lightMat);
            scene.add(lightningMesh);
        }

        function initSplashParticles() {
            const geometry = new THREE.BufferGeometry();
            splashPositions = new Float32Array(MAX_SPLASH_PARTICLES * 3);
            for(let i=0; i<MAX_SPLASH_PARTICLES; i++) {
                splashPositions[i*3] = 0; splashPositions[i*3+1] = -1000; splashPositions[i*3+2] = 0;
                splashVelocities.push(new THREE.Vector3(0,0,0));
                splashLifetimes.push(0);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(splashPositions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8 });
            splashParticles = new THREE.Points(geometry, material);
            scene.add(splashParticles);
        }

        function createSplash(x, y, z, count, speedModifier = 1.0) {
            let created = 0;
            for(let i=0; i<MAX_SPLASH_PARTICLES && created < count; i++) {
                if(splashLifetimes[i] <= 0) {
                    splashPositions[i*3] = x + (Math.random() - 0.5);
                    splashPositions[i*3+1] = y;
                    splashPositions[i*3+2] = z + (Math.random() - 0.5);
                    splashVelocities[i].set((Math.random() - 0.5) * 5 * speedModifier, (Math.random() * 8 + 4) * speedModifier, (Math.random() - 0.5) * 5 * speedModifier);
                    splashLifetimes[i] = 1.0; 
                    created++;
                }
            }
        }

        function addBlock(x, y, z, type, colorHex = null) {
            const floorY = Math.floor(y);
            const bx = Math.floor(x);
            const bz = Math.floor(z);
            const key = `${bx},${floorY},${bz}`;
            
            if (type === TYPES.WATER) {
                if (waterSet.has(key)) return; 
                waterSet.add(key);
                blockData[type].push({x, y, z, color: colorHex});
                return;
            }

            if(type !== TYPES.FLOWER && type !== TYPES.STEM && type !== TYPES.TORCH) {
                blocksMap.set(key, type);
            }
            blockData[type].push({x, y, z, color: colorHex});
        }

        function fillInvisibleCollisionBox(minX, maxX, minY, maxY, minZ, maxZ) {
            for(let x=minX; x<=maxX; x++) {
                for(let y=minY; y<=maxY; y++) {
                    for(let z=minZ; z<=maxZ; z++) {
                        blocksMap.set(`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`, INVISIBLE_BARRIER);
                    }
                }
            }
        }

        function getSmoothTerrainHeight(x, z, originalHeight) {
            const clearings = [
                {cx: 175, cz: 100, r: 16, blend: 10, h: 3},   
                {cx: 335, cz: 135, r: 12, blend: 12, h: 10}, 
                {cx: 100, cz: 350, r: 16, blend: 12, h: 24}, 
                {cx: 300, cz: 300, r: 20, blend: 12, h: 5},
                {cx: 45, cz: 95, r: 15, blend: 10, h: 3}
            ];
            let finalHeight = originalHeight;
            for (let c of clearings) {
                const dist = Math.hypot(x - c.cx, z - c.cz);
                if (dist < c.r) {
                    return c.h; 
                } else if (dist < c.r + c.blend) {
                    let factor = (dist - c.r) / c.blend;
                    factor = factor * factor * (3 - 2 * factor);
                    finalHeight = c.h * (1 - factor) + originalHeight * factor;
                }
            }
            return finalHeight;
        }

        function addFireParticles(x, y, z, count = 60, height = 3.5, spread = 0.8, alwaysOn = false) {
            const pGeo = new THREE.BufferGeometry();
            const pPos = [];
            for(let i=0; i<count; i++) {
                pPos.push((Math.random()-0.5)*spread, Math.random()*(height/2), (Math.random()-0.5)*spread);
            }
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            const pSys = new THREE.Points(pGeo, new THREE.PointsMaterial({color: 0xffaa00, size: 0.25, transparent: true, opacity: 0.0}));
            pSys.position.set(x, y, z);
            pSys.userData = { height: height, spread: spread, alwaysOn: alwaysOn };
            scene.add(pSys);
            fireParticleSystems.push(pSys);
        }

        function buildTorch(x, y, z) {
            addBlock(x, y, z, TYPES.STEM, 0x5c4033); 
            addBlock(x, y + 0.6, z, TYPES.TORCH);
            const light = new THREE.PointLight(0xffaa00, 0.0, 20);
            light.position.set(x, y + 1.0, z);
            scene.add(light);
            dynamicLights.push({light: light, maxIntensity: 2.5});
            addFireParticles(x, y + 0.8, z, 15, 1.0, 0.3);
        }

        function buildCampfire(x, floorYLevel, z) {
            const fireGroup = new THREE.Group();
            const logGeo = new THREE.CylinderGeometry(0.3, 0.3, 2.5, 8);
            const logMat = new THREE.MeshLambertMaterial({ map: texWood });
            
            const groundY = floorYLevel - 0.5;
            
            for(let i=0; i<4; i++) {
                const log = new THREE.Mesh(logGeo, logMat);
                log.rotation.x = Math.PI / 2;
                log.rotation.z = (Math.PI / 4) * i;
                log.position.set(x, groundY + 0.3, z);
                fireGroup.add(log);
            }
            scene.add(fireGroup);
            
            const light = new THREE.PointLight(0xff8800, 0.0, 40);
            light.position.set(x, groundY + 2, z);
            scene.add(light);
            dynamicLights.push({light: light, maxIntensity: 4.0});
            addFireParticles(x, groundY + 0.5, z, 60, 3.5, 0.8);
        }

        function generateWorld() {
            const oceanLevel = 2;
            const islandRadius = 80;

            const getEdgeBlend = (dist) => {
                if (dist < 55) return 0;
                if (dist > 80) return 1;
                return (dist - 55) / 25;
            };

            const isSafeForVegetation = (x, z) => {
                if (Math.hypot(x - 175, z - 100) < 22) return false; 
                if (Math.hypot(x - 335, z - 135) < 16) return false; 
                if (Math.hypot(x - 100, z - 350) < 22) return false; 
                if (Math.hypot(x - 300, z - 300) < 24) return false; 
                if (Math.hypot(x - 45, z - 95) < 20) return false;
                return true;
            };

            for(let x=0; x<=200; x++) {
                for(let z=0; z<=200; z++) {
                    const dist = Math.sqrt((x-100)**2 + (z-100)**2);
                    if(dist < islandRadius) {
                        let rawHeight = 3; 
                        if(dist < 25) rawHeight += Math.floor(45 - dist * 1.8);
                        
                        let blendedHeight = Math.max(2, Math.floor(rawHeight * (1 - getEdgeBlend(dist)) + 2 * getEdgeBlend(dist)));
                        let height = Math.floor(getSmoothTerrainHeight(x, z, blendedHeight));

                        let isLavaRiver = false;
                        if (dist >= 5 && dist < 40) {
                            const angle = Math.atan2(z - 100, x - 100) * 180 / Math.PI;
                            if (Math.abs(angle - 45) < 12) isLavaRiver = true; 
                            if (Math.abs(angle - (-135)) < 12) isLavaRiver = true; 
                        }

                        for(let y=Math.max(0, height-3); y<=height; y++) {
                            let type = TYPES.SAND;
                            if(height > 5 && y > 3) type = TYPES.STONE;
                            if(y === height && dist < 5 && height > 5) type = TYPES.LAVA;
                            if(y === height && isLavaRiver && height > 2) type = TYPES.LAVA;
                            addBlock(x, y, z, type);
                        }

                        if(height <= 4 && height >= 2 && isSafeForVegetation(x, z) && !isLavaRiver && Math.random() < 0.03) {
                            const treeH = 5 + Math.floor(Math.random()*4);
                            for(let py=1; py<=treeH; py++) addBlock(x, height+py, z, TYPES.WOOD);
                            const topY = height + treeH;
                            addBlock(x, topY+1, z, TYPES.LEAVES);
                            for(let dx=-2; dx<=2; dx++) {
                                for(let dz=-2; dz<=2; dz++) {
                                    if (Math.abs(dx) + Math.abs(dz) <= 2 && !(dx===0 && dz===0)) addBlock(x+dx, topY, z+dz, TYPES.LEAVES);
                                }
                            }
                        }
                    }
                }
            }

            const peaks = [{x: 300, z: 100, h: 48}, {x: 275, z: 85, h: 35}, {x: 325, z: 120, h: 42}];
            const caveCenter = {x: 270, y: 4, z: 120}; 

            for(let x=200; x<=400; x++) {
                for(let z=0; z<=200; z++) {
                    const dist = Math.sqrt((x-300)**2 + (z-100)**2);
                    if(dist < islandRadius) {
                        let rawHeight = 2;
                        for(let p of peaks) {
                            const pDist = Math.sqrt((x-p.x)**2 + (z-p.z)**2);
                            const h = p.h - pDist * 1.2;
                            if(h > rawHeight) rawHeight = h;
                        }
                        
                        let blendedHeight = Math.max(2, Math.floor(rawHeight * (1 - getEdgeBlend(dist)) + 2 * getEdgeBlend(dist)));
                        let height = Math.floor(getSmoothTerrainHeight(x, z, blendedHeight));
                        
                        let minY = Math.max(0, height - 3);
                        const distToCaveCenter = Math.hypot(x-caveCenter.x, z-caveCenter.z);
                        if (distToCaveCenter < 20) minY = 0; 

                        for(let y=minY; y<=height; y++) {
                            const dx = x - caveCenter.x;
                            const dy = (y - caveCenter.y) * 1.5; 
                            const dz = z - caveCenter.z;
                            const distToCave = Math.sqrt(dx*dx + dy*dy + dz*dz);
                            
                            if(distToCave < 10 && y > 3 && y < 14) continue; 

                            let type = TYPES.DIRT;
                            if(y === height) {
                                if(y > 25) type = TYPES.SNOW;
                                else if(y > 10) type = TYPES.STONE;
                                else type = TYPES.GRASS;
                            } else if(y > 10) {
                                type = TYPES.STONE;
                            }
                            addBlock(x, y, z, type);
                        }
                    }
                }
            }

            for(let x=0; x<=200; x++) {
                for(let z=200; z<=400; z++) {
                    const dist = Math.sqrt((x-100)**2 + (z-300)**2);
                    if(dist < islandRadius) {
                        let rawHeight = 4;
                        let localZ = z - 300;
                        let localX = x - 100;
                        
                        if (localZ > 10) {
                            rawHeight = 24; 
                            if (Math.abs(localX) > 20) rawHeight = 4 + Math.max(0, 20 - (Math.abs(localX) - 20)*1.2);
                        } else if (localZ > -10) {
                            let factor = (localZ + 10) / 20;
                            rawHeight = 4 + (20 * factor);
                            if (Math.abs(localX) > 20) rawHeight = Math.min(rawHeight, 4 + Math.max(0, 20 - (Math.abs(localX) - 20)*1.2));
                        }

                        let blendedHeight = Math.max(2, Math.floor(rawHeight * (1 - getEdgeBlend(dist)) + 2 * getEdgeBlend(dist)));
                        let height = Math.floor(getSmoothTerrainHeight(x, z, blendedHeight));

                        const distToTower = Math.hypot(x - 100, z - 350);
                        const isRiver = (Math.abs(localX) <= 3 && localZ > -100) && distToTower > 14;

                        let maxLoopY = height;
                        let minY = Math.max(0, height - 3);

                        if (isRiver) {
                            if (localZ > -10 && localZ < 10) {
                                maxLoopY = 24; minY = 0; 
                            } else if (localZ <= -10) {
                                maxLoopY = Math.max(height, 2); minY = 0;
                            }
                        }

                        for(let y=minY; y<=maxLoopY; y++) {
                            if (isRiver) {
                                if (localZ >= 10) {
                                    if (y < height - 1) addBlock(x, y, z, TYPES.STONE);
                                    else if (y === height - 1) addBlock(x, y, z, TYPES.DIRT);
                                    else if (y === height) addBlock(x, y, z, TYPES.WATER);
                                } else if (localZ > -10 && localZ < 10) {
                                    if (y < height - 1) addBlock(x, y, z, TYPES.STONE);
                                    else if (y >= height && y <= 24) addBlock(x, y, z, TYPES.WATER);
                                } else { 
                                    if (y === 0) addBlock(x, y, z, TYPES.STONE);
                                    else if (y === 1) addBlock(x, y, z, TYPES.DIRT);
                                    else if (y === 2) addBlock(x, y, z, TYPES.WATER);
                                }
                            } else {
                                if (y <= height) addBlock(x, y, z, y === height ? TYPES.GRASS : TYPES.DIRT);
                            }
                        }

                        if(!isRiver && isSafeForVegetation(x, z)) {
                            if(Math.random() < 0.08 && height >= 4) {
                                const treeH = 8 + Math.floor(Math.random()*6);
                                for(let py=1; py<=treeH; py++) addBlock(x, height+py, z, TYPES.WOOD);
                                for(let dx=-3; dx<=3; dx++) {
                                    for(let dy=-2; dy<=3; dy++) {
                                        for(let dz=-3; dz<=3; dz++) {
                                            if(dx*dx + dy*dy + dz*dz <= 10) addBlock(x+dx, height+treeH+dy, z+dz, TYPES.LEAVES);
                                        }
                                    }
                                }
                            }
                            if(Math.random() < 0.12 && height >= 4) {
                                const colors = [0xff0000, 0xffff00, 0x0000ff, 0xff00ff, 0xffa500, 0xffffff];
                                addBlock(x, height+1, z, TYPES.STEM);
                                addBlock(x, height+1.4, z, TYPES.FLOWER, colors[Math.floor(Math.random()*colors.length)]);
                            }
                        }
                    }
                }
            }

            for(let x=200; x<=400; x++) {
                for(let z=200; z<=400; z++) {
                    const dist = Math.sqrt((x-300)**2 + (z-300)**2);
                    if(dist < islandRadius) {
                        let dunaHeight = Math.sin(x * 0.1) * 2 + Math.cos(z * 0.1) * 2;
                        let rawHeight = 4 + Math.max(0, dunaHeight);

                        let blendedHeight = Math.max(2, Math.floor(rawHeight * (1 - getEdgeBlend(dist)) + 2 * getEdgeBlend(dist)));
                        let height = Math.floor(getSmoothTerrainHeight(x, z, blendedHeight));

                        for(let y=Math.max(0, height - 3); y<=height; y++) {
                            addBlock(x, y, z, TYPES.SAND);
                        }

                        if(Math.random() < 0.01 && height >= 3 && isSafeForVegetation(x, z)) {
                            const cHeight = 3 + Math.floor(Math.random()*4);
                            for(let py=1; py<=cHeight; py++) addBlock(x, height+py, z, TYPES.CACTUS);
                            if(cHeight > 3 && Math.random() > 0.5) addBlock(x+1, height+3, z, TYPES.CACTUS);
                            if(cHeight > 4 && Math.random() > 0.5) addBlock(x-1, height+4, z, TYPES.CACTUS);
                        }
                    }
                }
            }

            for (let x = -100; x <= 500; x++) {
                for (let z = -100; z <= 500; z++) {
                    let topFloor = getFloorHeight(x, z, 50);
                    if (topFloor <= oceanLevel && !isInsideStructure(x, z, oceanLevel)) {
                        addBlock(x, oceanLevel, z, TYPES.WATER);
                    }
                }
            }

            let rotY85 = Math.atan2(85 - 100, 45 - 100) - Math.PI;
            buildMoai(45, getFloorHeight(45, 85, 50), 85, rotY85);

            let rotY95 = Math.atan2(95 - 100, 45 - 100) - Math.PI;
            buildMoai(45, getFloorHeight(45, 95, 50), 95, rotY95);

            let rotY105 = Math.atan2(105 - 100, 45 - 100) - Math.PI;
            buildMoai(45, getFloorHeight(45, 105, 50), 105, rotY105);

            buildCampfire(270, getFloorHeight(270, 120, 50), 120);
            
            let hutFireX = 328;
            let hutFireZ = 146;
            let hutFireY = getFloorHeight(hutFireX, hutFireZ, 50);
            buildCampfire(hutFireX, hutFireY, hutFireZ);
            
            buildLogHut(335, 10, 135);
            buildShipwreck(175, 2, 100);
            buildHinduTemple(100, 24, 350);
            buildHugePyramid(300, 5, 300);

            function placeTorchAt(tx, tz) {
                let ty = getFloorHeight(tx, tz, 50);
                buildTorch(tx, ty, tz);
            }
            
            placeTorchAt(100 - 12, 350 - 12);
            placeTorchAt(100 + 12, 350 - 12);
            placeTorchAt(100 - 12, 350 + 12);
            placeTorchAt(100 + 12, 350 + 12);
            
            placeTorchAt(100 - 3, 350 - 14);
            placeTorchAt(100 + 3, 350 - 14);

            const blockGeo = new THREE.BoxGeometry(1, 1, 1);
            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            for(let key in TYPES) {
                const typeId = TYPES[key];
                const data = blockData[typeId];
                if(data.length === 0) continue;

                let geo = blockGeo;
                if(typeId === TYPES.FLOWER) geo = new THREE.BoxGeometry(0.7, 0.1, 0.7); 
                if(typeId === TYPES.STEM) geo = new THREE.BoxGeometry(0.1, 0.8, 0.1);   
                if(typeId === TYPES.TORCH) geo = new THREE.BoxGeometry(0.15, 0.5, 0.15); 

                const materialsArray = Array.isArray(MATERIALS[typeId]) ? MATERIALS[typeId] : MATERIALS[typeId];
                const mesh = new THREE.InstancedMesh(geo, materialsArray, data.length);
                
                for(let i=0; i<data.length; i++) {
                    matrix.setPosition(data[i].x, data[i].y, data[i].z);
                    mesh.setMatrixAt(i, matrix);
                    
                    if(data[i].color !== null) {
                        color.setHex(data[i].color);
                        mesh.setColorAt(i, color);
                    } else {
                        color.setHex(0xffffff);
                        const hsl = {};
                        color.getHSL(hsl);
                        color.setHSL(hsl.h, hsl.s, hsl.l - Math.random() * 0.05);
                        mesh.setColorAt(i, color);
                    }
                }
                scene.add(mesh);
                instancedMeshes[typeId] = mesh;
            }

            let canteenY = getFloorHeight(294, 316, 50);
            addBlock(294, canteenY, 316, TYPES.CACTUS);
            addBlock(294, canteenY + 1, 316, TYPES.CACTUS);
            createCollectibleMesh('canteen', 295, getFloorHeight(295, 316, 50), 316);

            let macheteY = getFloorHeight(100, 363, 50);
            createCollectibleMesh('machete', 100, macheteY, 363);

            let stickY = getFloorHeight(300, 100, 60);
            createCollectibleMesh('stick', 300, stickY, 100);

            let lanternY = getFloorHeight(155, 100, 50);
            createCollectibleMesh('lantern', 155, lanternY, 100);

            const pGeo = new THREE.BufferGeometry();
            const pPos = [];
            for(let i=0; i<400; i++) pPos.push(100 + (Math.random()-0.5)*6, 45 + Math.random()*20, 100 + (Math.random()-0.5)*6);
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            volcanoParticles = new THREE.Points(pGeo, new THREE.PointsMaterial({color: 0xff3300, size: 0.8}));
            scene.add(volcanoParticles);
        }

        function buildMoai(cx, cy, cz, rotY) {
            const blocks = [];
            function addM(dx, dy, dz) {
                blocks.push({x: dx, y: dy, z: dz});
            }
            
            for(let y=0; y<=1; y++) {
                for(let dx=0; dx<=2; dx++) {
                    for(let dz=-1; dz<=1; dz++) addM(dx, y, dz);
                }
            }
            for(let y=2; y<=3; y++) {
                for(let dx=0; dx<=2; dx++) {
                    for(let dz=-2; dz<=2; dz++) addM(dx, y, dz);
                }
                for(let dz=-2; dz<=2; dz++) addM(-1, y, dz);
            }
            for(let dx=0; dx<=2; dx++) {
                for(let dz=-1; dz<=1; dz++) addM(dx, 4, dz);
            }
            for(let y=5; y<=6; y++) {
                for(let dx=0; dx<=2; dx++) {
                    for(let dz=-1; dz<=1; dz++) addM(dx, y, dz);
                }
                addM(-1, y, 0);
            }
            for(let dx=0; dx<=2; dx++) {
                for(let dz=-1; dz<=1; dz++) {
                    if (dx === 0 && (dz === -1 || dz === 1)) continue;
                    addM(dx, 7, dz);
                }
            }
            addM(-1, 7, 0); 
            for(let dx=0; dx<=2; dx++) {
                for(let dz=-1; dz<=1; dz++) addM(dx, 8, dz);
            }
            for(let dz=-1; dz<=1; dz++) addM(-1, 8, dz);
            for(let y=9; y<=11; y++) {
                for(let dx=0; dx<=2; dx++) {
                    for(let dz=-1; dz<=1; dz++) addM(dx, y, dz);
                }
            }

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const imesh = new THREE.InstancedMesh(geo, MATERIALS[TYPES.STONE], blocks.length);
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            const hsl = {};
            
            for(let i=0; i<blocks.length; i++) {
                dummy.position.set(blocks[i].x, blocks[i].y, blocks[i].z);
                dummy.updateMatrix();
                imesh.setMatrixAt(i, dummy.matrix);
                
                color.setHex(0xffffff);
                color.getHSL(hsl);
                color.setHSL(hsl.h, hsl.s, hsl.l - Math.random() * 0.05);
                imesh.setColorAt(i, color);
            }
            
            imesh.position.set(cx, cy, cz);
            imesh.rotation.y = rotY;
            scene.add(imesh);

            for (let y = 0; y <= 11; y++) {
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        blocksMap.set(`${Math.floor(cx + dx)},${Math.floor(cy + y)},${Math.floor(cz + dz)}`, INVISIBLE_BARRIER);
                    }
                }
            }
        }

        // ZONE 1: Hut (Block 1)
        function buildLogHut(cx, cy, cz) {
            const hutGroup = new THREE.Group();
            const wallMat = new THREE.MeshLambertMaterial({ map: texWood });
            const roofMat = new THREE.MeshLambertMaterial({ map: texPlank });
            const floorMat = new THREE.MeshLambertMaterial({ map: texDirt });

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMat);
            floor.rotation.x = -Math.PI / 2; floor.position.set(0, 0.1, 0); hutGroup.add(floor);
            const wBack = new THREE.Mesh(new THREE.BoxGeometry(12, 5, 1), wallMat); wBack.position.set(0, 2.5, -5.5); hutGroup.add(wBack);
            const wLeft = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 10), wallMat); wLeft.position.set(-5.5, 2.5, 0); hutGroup.add(wLeft);
            const wRight = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 10), wallMat); wRight.position.set(5.5, 2.5, 0); hutGroup.add(wRight);
            const wFront1 = new THREE.Mesh(new THREE.BoxGeometry(4, 5, 1), wallMat); wFront1.position.set(-4, 2.5, 5.5); hutGroup.add(wFront1);
            const wFront2 = new THREE.Mesh(new THREE.BoxGeometry(4, 5, 1), wallMat); wFront2.position.set(4, 2.5, 5.5); hutGroup.add(wFront2);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(9, 4, 4), roofMat); roof.rotation.y = Math.PI / 4; roof.position.set(0, 7, 0); hutGroup.add(roof);

            hutGroup.position.set(cx, cy, cz);
            scene.add(hutGroup);

            fillInvisibleCollisionBox(cx - 6, cx + 6, cy, cy + 10, cz - 6, cz - 5); 
            fillInvisibleCollisionBox(cx - 6, cx - 5, cy, cy + 10, cz - 5, cz + 5); 
            fillInvisibleCollisionBox(cx + 5, cx + 6, cy, cy + 10, cz - 5, cz + 5); 
            fillInvisibleCollisionBox(cx - 6, cx - 2, cy, cy + 10, cz + 5, cz + 6); 
            fillInvisibleCollisionBox(cx + 2, cx + 6, cy, cy + 10, cz + 5, cz + 6); 
            fillInvisibleCollisionBox(cx - 5, cx + 5, cy + 8, cy + 9, cz - 5, cz + 5);

            createControlledDoor(cx - 2, cy + 0.1, cz + 5.5, 4, 4.8, 2, 0, 0, Math.PI / 1.5, 1);
            
            createInteractable(new THREE.BoxGeometry(1.5, 1.2, 1.0), new THREE.MeshLambertMaterial({color:0x3e2723}), cx+3, cy+0.6, cz-3, {type:'desk', zone:1});
            createInteractable(new THREE.BoxGeometry(0.8, 0.2, 0.6), new THREE.MeshLambertMaterial({color:0x8b0000}), cx+3, cy+1.3, cz-3, {type:'book', zone:1});
            
            const compassGroup = new THREE.Group();
            const cBase = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.1, 16), new THREE.MeshLambertMaterial({color: 0xff8800}));
            const cFace = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.12, 16), new THREE.MeshLambertMaterial({color: 0xffffff}));
            const cNeedle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.16, 0.7), new THREE.MeshLambertMaterial({color: 0xcc0000}));
            cBase.rotation.x = Math.PI/2;
            cFace.rotation.x = Math.PI/2;
            cNeedle.rotation.x = Math.PI/2;
            cNeedle.rotation.y = Math.PI/4; 
            compassGroup.add(cBase, cFace, cNeedle);
            createComplexInteractable(compassGroup, cx, cy + 2.0, cz - 4.9, {type:'lever', zone:1});
        }

        // ZONE 2: Shipwreck (Block 2)
        function buildShipwreck(cx, cy, cz) {
            const p = TYPES.PLANK;
            const l = TYPES.WOOD;

            for(let y=0; y<=8; y++) {
                for(let dx=-4; dx<=4; dx++) {
                    for(let dz=-14; dz<=3; dz++) {
                        let isBlock = false;
                        
                        let width = 4;
                        let maxHeight = 3; 

                        if (dz === -6 || dz === -7) {
                            width = 3;
                            maxHeight = 4;
                        } else if (dz === -8 || dz === -9) {
                            width = 2;
                            maxHeight = 5;
                        } else if (dz === -10 || dz === -11) {
                            width = 1;
                            maxHeight = 6;
                        } else if (dz <= -12) {
                            width = 0;
                            maxHeight = 7;
                        }

                        if (Math.abs(dx) <= width && y <= maxHeight) {
                            isBlock = true;
                        }

                        if (y > 1 && y < maxHeight && Math.abs(dx) < width) {
                            isBlock = false; 
                        }

                        if (dz >= -5 && dz <= 3 && y === 4 && Math.abs(dx) === width) {
                            isBlock = true; 
                        }

                        if (isBlock && Math.random() > 0.92 && y >= 2 && Math.abs(dx) >= width - 1) {
                            isBlock = false;
                        }

                        if (isBlock) addBlock(cx+dx, cy+y, cz+dz, p);
                    }
                }
            }

            for (let y = 0; y <= 5; y++) {
                for (let dx = -4; dx <= 4; dx++) {
                    for (let dz = 4; dz <= 12; dz++) {
                        let isBlock = false;
                        if (y === 0 && Math.abs(dx) <= 4) isBlock = true; 
                        if (y === 5 && Math.abs(dx) <= 4) isBlock = true; 
                        if (y >= 1 && y <= 4 && Math.abs(dx) === 4) isBlock = true; 
                        if (y >= 1 && y <= 4 && dz === 12 && Math.abs(dx) <= 4) isBlock = true; 
                        if (y >= 1 && y <= 4 && dz === 4 && Math.abs(dx) <= 3) isBlock = true; 
                        
                        if (dz === 12 && (dx === 0 || dx === -1) && y >= 1 && y <= 3) isBlock = false;

                        if (isBlock) addBlock(cx+dx, cy+y, cz+dz, p);
                    }
                }
            }

            for(let y=2; y<=12; y++) addBlock(cx, cy+y, cz-8, l);
            for(let dx=-3; dx<=3; dx++) addBlock(cx+dx, cy+11, cz-8, l);

            for(let y=2; y<=16; y++) addBlock(cx, cy+y, cz-1, l);
            for(let dx=-4; dx<=4; dx++) addBlock(cx+dx, cy+15, cz-1, l);

            for(let y=6; y<=14; y++) addBlock(cx, cy+y, cz+7, l);
            for(let dx=-3; dx<=3; dx++) addBlock(cx+dx, cy+13, cz+7, l);

            let bz = -12;
            let by = 5;
            for (let i = 0; i < 3; i++) {
                bz--; addBlock(cx, cy+by, cz+bz, l);
                bz--; addBlock(cx, cy+by, cz+bz, l);
                by++;
                if (i < 2) addBlock(cx, cy+by, cz+bz, l);
            }

            createControlledDoor(cx-1.5, cy+0.5, cz+12.2, 2, 3, 1, 0, 0, Math.PI / 1.5, 2);

            createInteractable(new THREE.BoxGeometry(1.2, 1.4, 2.2), new THREE.MeshLambertMaterial({color:0x5c4033}), cx+2, cy+0.7, cz+8, {type:'desk', zone:2});
            createInteractable(new THREE.BoxGeometry(0.8, 0.2, 0.6), new THREE.MeshLambertMaterial({color:0x00008b}), cx+2, cy+1.5, cz+8, {type:'book', zone:2});
            
            createInteractable(new THREE.CylinderGeometry(0.25, 0.35, 2.0, 16), new THREE.MeshLambertMaterial({color: 0x3e2723}), cx - 3.4, cy + 1.0, cz + 9, {type:'desk', zone:2});
            
            const astroGroup = new THREE.Group();
            const t1 = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.04, 16, 32), new THREE.MeshLambertMaterial({color: 0xffd700}));
            const t2 = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.04, 16, 32), new THREE.MeshLambertMaterial({color: 0xffd700}));
            t2.rotation.x = Math.PI/2;
            const sObj = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), new THREE.MeshLambertMaterial({color: 0x8888ff}));
            astroGroup.add(t1, t2, sObj);
            createComplexInteractable(astroGroup, cx - 3.4, cy + 2.4, cz + 9, {type:'lever', zone:2});
        }

        // ZONE 3: Hindu Temple (Block 3)
        function buildHinduTemple(cx, cy, cz) {
            const s1 = TYPES.SAND;
            const s2 = TYPES.DIRT; 
            
            for (let y = 0; y <= 1; y++) {
                const r = 12 - y * 2;
                for (let dx = -r; dx <= r; dx++) {
                    for (let dz = -r; dz <= r; dz++) {
                        addBlock(cx + dx, cy + y, cz + dz, (Math.abs(dx)%2===0 && Math.abs(dz)%2===0) ? s2 : s1);
                    }
                }
            }

            for(let y=0; y<=1; y++) {
                for(let dx=-2; dx<=2; dx++) {
                    for(let dz=-14+y*2; dz<=-11; dz++) {
                        addBlock(cx+dx, cy+y, cz+dz, s1);
                    }
                }
            }

            const roomR = 7;
            for (let y = 2; y <= 10; y++) {
                for (let dx = -roomR; dx <= roomR; dx++) {
                    for (let dz = -roomR; dz <= roomR; dz++) {
                        if (Math.abs(dx) === roomR || Math.abs(dz) === roomR) {
                            if (dz === -roomR && Math.abs(dx) <= 1 && y >= 2 && y <= 6) continue;
                            
                            if (Math.abs(dx) === roomR && Math.abs(dz) === roomR) addBlock(cx+dx, cy+y, cz+dz, s2);
                            else if (y === 5 || y === 9) addBlock(cx+dx, cy+y, cz+dz, s2);
                            else addBlock(cx + dx, cy + y, cz + dz, s1);
                        }
                    }
                }
            }

            for (let y = 2; y <= 6; y++) {
                addBlock(cx - 3, cy + y, cz - 9, s2);
                addBlock(cx + 3, cy + y, cz - 9, s2);
                addBlock(cx - 3, cy + y, cz - 8, s1);
                addBlock(cx + 3, cy + y, cz - 8, s1);
            }
            
            for(let y = 7; y <= 9; y++) {
                let pr = 9 - y + 1; 
                for(let dx = -pr; dx <= pr; dx++) {
                    for(let dz = -10; dz <= -7; dz++) {
                        addBlock(cx + dx, cy + y, cz + dz, s1);
                    }
                }
            }

            const tiers = [
                { yStart: 11, yEnd: 13, r: 8 },
                { yStart: 14, yEnd: 16, r: 6 },
                { yStart: 17, yEnd: 19, r: 4 },
                { yStart: 20, yEnd: 22, r: 2 }
            ];

            for (let t of tiers) {
                for (let y = t.yStart; y <= t.yEnd; y++) {
                    let currentR = t.r - (y - t.yStart);
                    if (currentR < 1) currentR = 1;
                    for (let dx = -currentR; dx <= currentR; dx++) {
                        for (let dz = -currentR; dz <= currentR; dz++) {
                            addBlock(cx + dx, cy + y, cz + dz, (y % 2 === 0) ? s1 : s2);
                        }
                    }
                    if (y === t.yStart) {
                        addBlock(cx - currentR - 1, cy + y, cz - currentR - 1, s2);
                        addBlock(cx + currentR + 1, cy + y, cz - currentR - 1, s2);
                        addBlock(cx - currentR - 1, cy + y, cz + currentR + 1, s2);
                        addBlock(cx + currentR + 1, cy + y, cz + currentR + 1, s2);
                    }
                }
            }
            
            addBlock(cx, cy + 23, cz, s1);
            addBlock(cx, cy + 24, cz, s2);

            createControlledDoor(cx - 1.5, cy + 1.1, cz - 7, 3, 4.8, 1.5, 0, 0, -Math.PI / 1.5, 3);

            createInteractable(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 8), new THREE.MeshLambertMaterial({color:0xffffff}), cx, cy+2.1, cz, {type:'desk', zone:3});
            createInteractable(new THREE.BoxGeometry(0.6, 0.2, 0.6), new THREE.MeshLambertMaterial({color:0x006400}), cx, cy+2.8, cz, {type:'book', zone:3});
            
            const colMat = new THREE.MeshLambertMaterial({color: 0xffffff});
            const vaseMat = new THREE.MeshLambertMaterial({color: 0x1E90FF});
            
            createInteractable(new THREE.CylinderGeometry(0.4, 0.4, 2, 16), colMat, cx + 6.1, cy + 2.5, cz, {type:'desk', zone:3});
            const vaseRightGroup = new THREE.Group();
            const vaseRight = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), vaseMat);
            vaseRight.scale.y = 1.5;
            vaseRightGroup.add(vaseRight);
            vaseRightGroup.position.set(cx + 6.1, cy + 3.95, cz);
            scene.add(vaseRightGroup);

            createInteractable(new THREE.CylinderGeometry(0.4, 0.4, 2, 16), colMat, cx - 6.1, cy + 2.5, cz, {type:'desk', zone:3});
            const vaseLeftGroup = new THREE.Group();
            const vaseLeft = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), vaseMat);
            vaseLeft.scale.y = 1.5;
            vaseLeftGroup.add(vaseLeft);
            createComplexInteractable(vaseLeftGroup, cx - 6.1, cy + 3.95, cz, {type:'lever', zone:3});
        }

        // ZONE 4: Pyramid (Block 4)
        function buildHugePyramid(cx, cy, cz) {
            const size = 15; 
            for(let h=0; h<=size; h++) {
                const r = size - h;
                for(let dx=-r; dx<=r; dx++) {
                    for(let dz=-r; dz<=r; dz++) {
                        if (dx===-r || dx===r || dz===-r || dz===r || h===size) {
                            if (h<4 && dx>=-1 && dx<=1 && dz===r) continue; 
                            addBlock(cx+dx, cy+h, cz+dz, TYPES.SAND);
                        } else if (h===0) {
                            addBlock(cx+dx, cy-1, cz+dz, TYPES.SAND); 
                        }
                    }
                }
            }
            
            addBlock(cx, cy, cz, TYPES.GOLD); 
            const light = new THREE.PointLight(0xffdd66, 0.0, 25);
            light.position.set(cx, cy + 3, cz);
            scene.add(light);
            dynamicLights.push({light: light, maxIntensity: 2.0});

            createControlledDoor(cx - 1.5, cy, cz + 15, 3, 6, 1.5, 0, 0, -Math.PI / 1.5, 4, -Math.PI / 4);

            createInteractable(new THREE.BoxGeometry(2, 1.2, 1), new THREE.MeshLambertMaterial({color:0xffd700}), cx, cy+0.1, cz+3, {type:'desk', zone:4});
            createInteractable(new THREE.BoxGeometry(0.8, 0.2, 0.6), new THREE.MeshLambertMaterial({color:0x800080}), cx, cy+0.8, cz+3, {type:'book', zone:4});
            
            function addPyramidTorch(tx, ty, tz, rotY, isInteractive) {
                const torchGroup = new THREE.Group();
                const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6), new THREE.MeshLambertMaterial({color: 0x5c4033}));
                stick.rotation.x = Math.PI / 4;
                const bracket = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.2), new THREE.MeshLambertMaterial({color: 0x333333}));
                bracket.position.z = -0.15;
                torchGroup.add(stick, bracket);
                
                torchGroup.rotation.y = rotY;
                
                if (isInteractive) {
                    createComplexInteractable(torchGroup, tx, ty, tz, {type:'lever', zone:4});
                } else {
                    torchGroup.position.set(tx, ty, tz);
                    scene.add(torchGroup);
                }
                
                const fX = tx + Math.sin(rotY) * 0.2;
                const fZ = tz + Math.cos(rotY) * 0.2;
                const fY = ty + 0.3;
                
                const fLight = new THREE.PointLight(0xffaa00, 0.0, 20);
                fLight.position.set(fX, fY, fZ);
                scene.add(fLight);
                dynamicLights.push({light: fLight, maxIntensity: 2.5, alwaysOn: true});
                addFireParticles(fX, fY, fZ, 15, 1.0, 0.3, true);
            }
            
            addPyramidTorch(cx - 11.5, cy + 3, cz, Math.PI/2, false);
            addPyramidTorch(cx, cy + 3, cz - 11.5, 0, false);
            addPyramidTorch(cx + 11.5, cy + 3, cz, -Math.PI/2, true);
        }

        function isInsideStructure(x, z, y) {
            if (x >= 171 && x <= 179 && z >= 103 && z <= 112 && y <= 7) return true; // Shipwreck cabin
            if (x > 328 && x < 342 && z > 128 && z < 142 && y < 20) return true; // Hut
            if (Math.abs(x - 100) <= 7 && Math.abs(z - 350) <= 7 && y >= 24 && y < 45) return true; // Temple
            if (x > 284 && x < 316 && z > 284 && z < 316 && y < 22) return true; // Pyramid
            return false;
        }

        function checkCollision(pos) {
            const r = 0.25; 
            const y1 = Math.round(pos.y - 1.4);
            const y2 = Math.round(pos.y - 0.8);
            const y3 = Math.round(pos.y - 0.2);
            
            const isSolid = (x, yLevel, z) => {
                const bx = Math.floor(x + 0.5);
                const bz = Math.floor(z + 0.5);
                const t = blocksMap.get(`${bx},${yLevel},${bz}`);
                return t && t !== TYPES.WATER && t !== TYPES.FLOWER && t !== TYPES.STEM && t !== TYPES.TORCH;
            };
            
            const checkPts = (x, z) => isSolid(x, y1, z) || isSolid(x, y2, z) || isSolid(x, y3, z);

            if (checkPts(pos.x, pos.z)) return true;
            if (checkPts(pos.x - r, pos.z - r)) return true;
            if (checkPts(pos.x + r, pos.z - r)) return true;
            if (checkPts(pos.x - r, pos.z + r)) return true;
            if (checkPts(pos.x + r, pos.z + r)) return true;

            const px = pos.x;
            const py = pos.y;
            const pz = pos.z;

            for (let i = 0; i < interactables.length; i++) {
                let obj = interactables[i];
                if (obj.userData && obj.userData.type === 'desk' && obj.userData.box) {
                    let b = obj.userData.box;
                    if (px + r > b.min.x && px - r < b.max.x &&
                        py > b.min.y && py - 1.5 < b.max.y &&
                        pz + r > b.min.z && pz - r < b.max.z) {
                        return true;
                    }
                }
            }

            for (let key in zones) {
                const zone = zones[key];
                if (zone.door && Math.abs(zone.door.group.rotation.y - zone.door.baseRot) < 0.1) {
                    const d = zone.door;
                    let minX = d.x - d.width / 2 - 0.2;
                    let maxX = d.x + d.width / 2 + 0.2;
                    let minY = d.y;
                    let maxY = d.y + d.height + 5.0; 

                    if (px + r > minX && px - r < maxX && py > minY && py - 1.5 < maxY) {
                        let minZ = d.z - 0.5;
                        let maxZ = d.z + 0.5;
                        
                        if (d.tiltX) {
                            let topZ = d.z + d.height * Math.tan(d.tiltX);
                            minZ = Math.min(d.z, topZ) - 0.5;
                            maxZ = Math.max(d.z, topZ) + 0.5;
                        }
                        
                        if (pz + r > minZ && pz - r < maxZ) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        function getFloorHeight(x, z, currentY) {
            const bx = Math.floor(x + 0.5);
            const bz = Math.floor(z + 0.5);
            const startY = Math.floor(currentY - 0.5);
            let highest = 0;
            
            for(let y = startY; y > -5; y--) {
                const type = blocksMap.get(`${bx},${y},${bz}`);
                if(type && type !== TYPES.WATER && type !== TYPES.FLOWER && type !== TYPES.STEM && type !== TYPES.TORCH && type !== INVISIBLE_BARRIER) {
                    highest = y + 1;
                    break;
                }
            }

            for(let i=0; i<interactables.length; i++) {
                let obj = interactables[i];
                if (obj.userData && obj.userData.type === 'desk' && obj.userData.box) {
                    let b = obj.userData.box;
                    if (x > b.min.x && x < b.max.x && z > b.min.z && z < b.max.z) {
                        if (b.max.y <= currentY + 0.5 && b.max.y > highest) {
                            highest = b.max.y;
                        }
                    }
                }
            }
            
            return highest;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateWeather(delta) {
            timeOfDay = (timeOfDay + delta) % 360;
            
            let isNight = timeOfDay >= 240;
            let sunAngle = !isNight ? (timeOfDay / 240) * Math.PI - Math.PI : ((timeOfDay - 240) / 120) * Math.PI; 
            
            dirLight.position.set(Math.cos(sunAngle) * 300, Math.sin(sunAngle) * 300, 200);
            
            let skyColor = new THREE.Color();
            
            if (!isNight) {
                skyColor.setHex(0x7EC8E3);
                ambientLight.intensity = 0.7;
                dirLight.intensity = 1.2;
            } else {
                skyColor.setHex(0x050515);
                ambientLight.intensity = 0.2;
                dirLight.intensity = 0.3;
            }

            if (!manualWeather) {
                weatherTimer -= delta;
                if(weatherTimer <= 0) {
                    weatherIndex = Math.floor(Math.random() * weatherTypes.length);
                    currentWeather = weatherTypes[weatherIndex];
                    weatherTimer = 40 + Math.random() * 40; 
                }
            }

            let weatherEmoji = {
                'SUNNY': isNight ? 'üåô' : '‚òÄÔ∏è', 'CLOUDY': '‚òÅÔ∏è', 'RAINY': 'üåßÔ∏è',
                'STORMY': '‚õàÔ∏è', 'WINDY': 'üå¨Ô∏è', 'FOGGY': 'üå´Ô∏è', 'SNOWY': '‚ùÑÔ∏è'
            }[currentWeather];
            document.getElementById('weatherDisplay').innerText = weatherEmoji;

            switch(currentWeather) {
                case 'SUNNY': targetWind = 0; targetSnow = 0; targetRain = 0; targetFogDensity = isNight ? 0.003 : 0.001; break;
                case 'CLOUDY': targetWind = 0.2; targetSnow = 0; targetRain = 0; targetFogDensity = 0.002; break;
                case 'RAINY': targetWind = 0.3; targetSnow = 0; targetRain = 1; targetFogDensity = 0.003; break;
                case 'STORMY': targetWind = 1.0; targetSnow = 0; targetRain = 1.5; targetFogDensity = 0.005; break;
                case 'WINDY': targetWind = 1.5; targetSnow = 0; targetRain = 0; targetFogDensity = 0.002; break;
                case 'FOGGY': targetWind = 0.1; targetSnow = 0; targetRain = 0; targetFogDensity = 0.02; break;
                case 'SNOWY': targetWind = 0.3; targetSnow = 1.0; targetRain = 0; targetFogDensity = 0.005; break;
            }

            globalUniforms.uWind.value += (targetWind - globalUniforms.uWind.value) * delta * 0.5;
            globalUniforms.uSnow.value += (targetSnow - globalUniforms.uSnow.value) * delta * 0.1; 
            globalUniforms.uRain.value += (targetRain - globalUniforms.uRain.value) * delta * 2.0;
            
            if (isTransitioningToGodView) {
                scene.fog.density = (1.0 - (transitionTime / 2.0)) * targetFogDensity;
            } else if (isGodView) {
                scene.fog.density = 0;
            } else if (isTransitioningFromGodView) {
                scene.fog.density = (transitionTime / 2.0) * targetFogDensity;
            } else {
                scene.fog.density += (targetFogDensity - scene.fog.density) * delta * 0.2;
            }

            if (currentWeather === 'FOGGY' || currentWeather === 'RAINY' || currentWeather === 'STORMY' || currentWeather === 'SNOWY') {
                skyColor.lerp(new THREE.Color(isNight ? 0x111111 : 0x8899aa), 0.8);
            }
            
            scene.background.lerpColors(scene.background, skyColor, delta * 0.5);
            scene.fog.color.copy(scene.background);

            let targetLight = isNight ? 1.0 : 0.0;
            for (let dl of dynamicLights) {
                let currentTarget = (isNight || dl.alwaysOn) ? 1.0 : 0.0;
                dl.light.intensity += (dl.maxIntensity * currentTarget - dl.light.intensity) * delta * 2.0;
            }

            if (audioCtx) {
                const inStructure = isInsideStructure(camera.position.x, camera.position.z, camera.position.y);
                const structureMuffle = inStructure ? 0.1 : 1.0;
                const muteFactor = isMuted ? 0 : 1.0;

                const targetRainVol = globalUniforms.uRain.value * 0.3 * structureMuffle * muteFactor;
                rainGain.gain.setTargetAtTime(targetRainVol, audioCtx.currentTime, 0.5);

                const targetWindVol = globalUniforms.uWind.value * 0.4 * structureMuffle * muteFactor;
                windGain.gain.setTargetAtTime(targetWindVol, audioCtx.currentTime, 0.5);
            }

            let targetCloudOpacity = (currentWeather !== 'SUNNY') ? 0.8 : 0.0;
            if(cloudParticles) {
                cloudParticles.material.opacity += (targetCloudOpacity - cloudParticles.material.opacity) * delta * 0.5;
                const windSpeed = globalUniforms.uWind.value * 5;
                const dummy = new THREE.Object3D();
                for(let i=0; i<50; i++) {
                    cloudParticles.getMatrixAt(i, dummy.matrix);
                    dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                    dummy.position.x += windSpeed * delta;
                    if(dummy.position.x > 600) dummy.position.x = -200;
                    dummy.updateMatrix();
                    cloudParticles.setMatrixAt(i, dummy.matrix);
                }
                cloudParticles.instanceMatrix.needsUpdate = true;
            }

            if(rainParticles) {
                rainParticles.material.opacity = globalUniforms.uRain.value > 0.1 ? 0.6 : 0;
                if(rainParticles.material.opacity > 0) {
                    rainParticles.position.x = camera.position.x;
                    rainParticles.position.z = camera.position.z;
                    const pos = rainParticles.geometry.attributes.position.array;
                    for(let i=1; i<pos.length; i+=3) {
                        pos[i] -= 30 * delta * globalUniforms.uRain.value;
                        pos[i-1] += globalUniforms.uWind.value * 10 * delta; 
                        
                        let worldX = rainParticles.position.x + pos[i-1];
                        let worldZ = rainParticles.position.z + pos[i+1];
                        
                        if(pos[i] < -20 || isInsideStructure(worldX, worldZ, pos[i])) {
                            pos[i] = 40 + Math.random()*20;
                            pos[i-1] = (Math.random() - 0.5) * 60;
                        }
                    }
                    rainParticles.geometry.attributes.position.needsUpdate = true;
                }
            }

            if(snowParticles) {
                snowParticles.material.opacity = targetSnow > 0.1 ? 0.8 : 0;
                if(snowParticles.material.opacity > 0) {
                    snowParticles.position.x = camera.position.x;
                    snowParticles.position.z = camera.position.z;
                    const pos = snowParticles.geometry.attributes.position.array;
                    for(let i=1; i<pos.length; i+=3) {
                        pos[i] -= 5 * delta;
                        pos[i-1] += Math.sin(timeOfDay * 2 + i) * 2 * delta + (globalUniforms.uWind.value * 5 * delta);
                        
                        let worldX = snowParticles.position.x + pos[i-1];
                        let worldZ = snowParticles.position.z + pos[i+1];
                        
                        if(pos[i] < -10 || isInsideStructure(worldX, worldZ, pos[i])) {
                            pos[i] = 40 + Math.random()*20;
                            pos[i-1] = (Math.random() - 0.5) * 60;
                        }
                    }
                    snowParticles.geometry.attributes.position.needsUpdate = true;
                }
            }

            if(currentWeather === 'STORMY') {
                if(Math.random() < 0.01 && lightningFlash <= 0) {
                    lightningFlash = 0.2; 
                    dirLight.intensity = 5.0; 
                    lightningMesh.position.set(camera.position.x + (Math.random()-0.5)*150, 40, camera.position.z + (Math.random()-0.5)*150);
                    lightningMesh.rotation.z = (Math.random()-0.5) * 0.5;
                    lightningMesh.rotation.x = (Math.random()-0.5) * 0.5;
                    lightningMesh.material.opacity = 1;

                    const inStructure = isInsideStructure(camera.position.x, camera.position.z, camera.position.y);
                    playThunder(inStructure);
                }
            }
            if(lightningFlash > 0) {
                lightningFlash -= delta;
                if(lightningFlash <= 0) {
                    dirLight.intensity = isNight ? 0.3 : 1.2;
                    lightningMesh.material.opacity = 0;
                }
            }
        }

        function updateZones(playerPos, delta) {
            for(let key in zones) {
                const zone = zones[key];
                const dist = Math.hypot(playerPos.x - zone.center.x, playerPos.z - zone.center.z);
                
                if (dist < zone.radius && !zone.inside) {
                    zone.inside = true;
                    if (!zone.completed) {
                        zone.door.targetRot = zone.door.baseRot; 
                        zone.locked = true;
                    }
                    
                    const titleEl = document.getElementById('zoneTitle');
                    titleEl.innerText = zone.titleText;
                    titleEl.classList.add('show');
                    
                    clearTimeout(zoneTitleTimeout);
                    zoneTitleTimeout = setTimeout(() => {
                        titleEl.classList.remove('show');
                    }, 5000);
                    
                } else if (dist > zone.radius && zone.inside) {
                    zone.inside = false;
                    const titleEl = document.getElementById('zoneTitle');
                    titleEl.classList.remove('show');
                }

                if (dist > zone.radius + 15 && zone.door && zone.door.targetRot !== zone.door.baseRot) {
                    zone.door.targetRot = zone.door.baseRot;
                }

                if (zone.door) {
                    zone.door.group.rotation.y += (zone.door.targetRot - zone.door.group.rotation.y) * 5.0 * delta;
                }
            }
        }

        function updateRaycast() {
            const textEl = document.getElementById('interactionText');
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(interactables, false);
            
            let foundValid = false;
            
            if (intersects.length > 0 && intersects[0].distance < 6) {
                const obj = intersects[0].object;
                const data = obj.userData;
                
                if(data.type === 'door') {
                    const zone = zones[data.zone];
                    if(zone.locked) {
                        textEl.innerText = "Locked - Pass the Test to Open";
                        textEl.style.color = "red";
                    } else {
                        textEl.innerText = "Click to open/close";
                        textEl.style.color = "white";
                    }
                    foundValid = true;
                } else if (data.type === 'book') {
                    textEl.innerText = "Click to read Verbs";
                    textEl.style.color = "yellow";
                    foundValid = true;
                } else if (data.type === 'lever') {
                    textEl.innerText = "Click to take Test";
                    textEl.style.color = "orange";
                    foundValid = true;
                } else if (data.type === 'collectible') {
                    textEl.innerText = "Click to collect object";
                    textEl.style.color = "cyan";
                    foundValid = true;
                }
            } 
            
            if (foundValid) {
                textEl.style.display = 'block';
            } else {
                textEl.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked === true) {
                updateWeather(delta);
                globalUniforms.uTime.value += delta;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                const playerPos = controls.getObject().position;
                
                updateZones(playerPos, delta);
                updateRaycast();

                const rawFloorY = getFloorHeight(playerPos.x, playerPos.z, playerPos.y);
                const floorTopY = rawFloorY - 0.5;
                const playerHeight = 1.6;
                const oceanLevel = 2.0;
                const waterSurfaceY = oceanLevel + 0.2; 
                const solidGroundY = floorTopY + playerHeight;
                
                let minHeight = solidGroundY;
                let isSwimming = false;

                if (solidGroundY < waterSurfaceY && floorTopY < oceanLevel && !isInsideStructure(playerPos.x, playerPos.z, oceanLevel)) {
                    minHeight = waterSurfaceY;
                    isSwimming = true;
                }

                if (isTransitioningToGodView) {
                    transitionTime += delta;
                    let t = transitionTime / 2.0; 
                    if (t >= 1.0) {
                        isTransitioningToGodView = false;
                        isGodView = true;
                        let finalX = (godViewLevel === 1) ? 200 : startTransitionPos.x;
                        let finalZ = (godViewLevel === 1) ? 200 : startTransitionPos.z;
                        controls.getObject().position.set(finalX, targetGodAltitude, finalZ);
                        camera.rotation.x = -Math.PI / 2;
                        controls.getObject().rotation.y = targetGodYaw;
                    } else {
                        let ease = t * t * (3 - 2 * t);
                        let finalX = (godViewLevel === 1) ? 200 : startTransitionPos.x;
                        let finalZ = (godViewLevel === 1) ? 200 : startTransitionPos.z;
                        controls.getObject().position.lerpVectors(startTransitionPos, new THREE.Vector3(finalX, targetGodAltitude, finalZ), ease);
                        camera.rotation.x = startTransitionPitch + (-Math.PI / 2 - startTransitionPitch) * ease;
                        controls.getObject().rotation.y = startTransitionYaw + (targetGodYaw - startTransitionYaw) * ease;
                    }
                } else if (isTransitioningFromGodView) {
                    transitionTime += delta;
                    let t = transitionTime / 2.0; 
                    if (t >= 1.0) {
                        isTransitioningFromGodView = false;
                        controls.getObject().position.copy(savedPos);
                        camera.rotation.set(savedPitch, 0, 0);
                        controls.getObject().rotation.set(0, savedYaw, 0);
                    } else {
                        let ease = t * t * (3 - 2 * t);
                        controls.getObject().position.lerpVectors(startTransitionPos, savedPos, ease);
                        camera.rotation.set(startTransitionPitch + (savedPitch - startTransitionPitch) * ease, 0, 0);
                        controls.getObject().rotation.set(0, startTransitionYaw + (savedYaw - startTransitionYaw) * ease, 0);
                    }
                } else if (!isGodView) {
                    if (isSwimming && !wasSwimming && velocity.y < -10) createSplash(playerPos.x, oceanLevel, playerPos.z, 40, 1.5); 
                    if (isSwimming && (Math.abs(velocity.x) > 2 || Math.abs(velocity.z) > 2)) {
                        if (Math.random() < 0.3) createSplash(playerPos.x, oceanLevel, playerPos.z, 2, 0.4);
                    }

                    if(globalUniforms.uRain.value > 0.5 && Math.random() < 0.2) {
                        const rx = playerPos.x + (Math.random()-0.5)*40;
                        const rz = playerPos.z + (Math.random()-0.5)*40;
                        if(!isInsideStructure(rx, rz, oceanLevel) && getFloorHeight(rx, rz, 50) <= oceanLevel) {
                            createSplash(rx, oceanLevel, rz, 1, 0.3);
                        }
                    }

                    if (isSwimming && playerPos.x > 96 && playerPos.x < 104 && playerPos.z > 190 && playerPos.z < 390) {
                        playerPos.z -= 18.0 * delta;
                    }

                    wasSwimming = isSwimming;

                    if (isSwimming) {
                        if (velocity.y < 0) velocity.y -= 15.0 * delta; 
                        else velocity.y -= 15.0 * delta; 
                    } else {
                        if (velocity.y < 0) velocity.y -= 90.0 * delta; 
                        else velocity.y -= 30.0 * delta; 
                    }

                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();

                    const speedMultiplier = isRunning ? 2.5 : 1.0;
                    const speed = (isSwimming ? 20.0 : 40.0) * speedMultiplier; 
                    if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                    const steps = 3;
                    const stepX = (-velocity.x * delta) / steps;
                    const stepZ = (-velocity.z * delta) / steps;

                    for (let s = 0; s < steps; s++) {
                        let wasColliding = checkCollision(controls.getObject().position);
                        
                        controls.moveRight(stepX);
                        if (!wasColliding && checkCollision(controls.getObject().position)) {
                            controls.moveRight(-stepX); 
                            velocity.x = 0;
                        }
                        
                        wasColliding = checkCollision(controls.getObject().position);
                        controls.moveForward(stepZ);
                        if (!wasColliding && checkCollision(controls.getObject().position)) {
                            controls.moveForward(-stepZ); 
                            velocity.z = 0;
                        }
                    }

                    if (velocity.y > 0) {
                        let testPos = controls.getObject().position.clone();
                        testPos.y += (velocity.y * delta) + 0.2;
                        if (checkCollision(testPos)) {
                            velocity.y = 0; 
                        }
                    }

                    controls.getObject().position.y += (velocity.y * delta);
                    if (controls.getObject().position.y < minHeight) {
                        velocity.y = 0;
                        controls.getObject().position.y = minHeight;
                        canJump = true;
                    }

                    const currentBx = Math.floor(playerPos.x + 0.5);
                    const currentBz = Math.floor(playerPos.z + 0.5);
                    const blockBeneath = blocksMap.get(`${currentBx},${rawFloorY - 1},${currentBz}`);
                    
                    if (blockBeneath === TYPES.LAVA && Math.abs(playerPos.y - solidGroundY) < 0.2) {
                        if (lavaDamageCooldown <= 0) {
                            applyLavaDamage();
                            lavaDamageCooldown = 5.0; 
                        }
                    }
                    if (lavaDamageCooldown > 0) {
                        lavaDamageCooldown -= delta;
                    }
                } else {
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();

                    const speed = 150.0;
                    if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
                    
                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);
                    
                    controls.getObject().position.y = targetGodAltitude;
                }
            }

            const runTime = time * 0.003;

            const pulseTime = time * 0.002;
            const pulseScale = 1.0 + Math.sin(pulseTime * 1.5) * 0.2;
            const pulseOpacity = 0.3 + Math.sin(pulseTime * 1.5) * 0.2;
            const lightIntensity = 1.5 + Math.sin(pulseTime * 1.5) * 1.0;

            for(let i = 0; i < collectibleHalos.length; i++) {
                let ch = collectibleHalos[i];
                if (ch.halo.parent) {
                    ch.halo.scale.set(pulseScale, pulseScale, pulseScale);
                    ch.halo.material.opacity = pulseOpacity;
                    ch.light.intensity = lightIntensity;
                }
            }

            if (MATERIALS[TYPES.WATER].userData.shader) {
                MATERIALS[TYPES.WATER].userData.shader.uniforms.uTime.value = runTime;
            }

            let isNightLocal = timeOfDay >= 240;
            for (let pSys of fireParticleSystems) {
                const targetOp = (isNightLocal || pSys.userData.alwaysOn) ? 0.9 : 0.0;
                pSys.material.opacity += (targetOp - pSys.material.opacity) * delta * 2.0;

                if (pSys.material.opacity > 0.01) {
                    const positions = pSys.geometry.attributes.position.array;
                    const h = pSys.userData.height;
                    const spread = pSys.userData.spread;
                    for(let i=1; i<positions.length; i+=3) {
                        positions[i] += (h/2) * delta;
                        if(positions[i] > h) {
                            positions[i] = 0; 
                            positions[i-1] = (Math.random()-0.5)*spread; 
                            positions[i+1] = (Math.random()-0.5)*spread; 
                        }
                    }
                    pSys.geometry.attributes.position.needsUpdate = true;
                }
            }

            if(splashParticles) {
                let active = false;
                for(let i=0; i<MAX_SPLASH_PARTICLES; i++) {
                    if(splashLifetimes[i] > 0) {
                        active = true;
                        splashLifetimes[i] -= delta;
                        splashVelocities[i].y -= 15.0 * delta; 
                        splashPositions[i*3] += splashVelocities[i].x * delta;
                        splashPositions[i*3+1] += splashVelocities[i].y * delta;
                        splashPositions[i*3+2] += splashVelocities[i].z * delta;
                        if(splashLifetimes[i] <= 0 || splashPositions[i*3+1] < 2.0) {
                            splashLifetimes[i] = 0;
                            splashPositions[i*3+1] = -1000; 
                        }
                    }
                }
                if (active) splashParticles.geometry.attributes.position.needsUpdate = true;
            }

            if(volcanoParticles) {
                const positions = volcanoParticles.geometry.attributes.position.array;
                for(let i=1; i<positions.length; i+=3) {
                    positions[i] += 0.2;
                    if(positions[i] > 65) {
                        positions[i] = 45; 
                        positions[i-1] = 100 + (Math.random()-0.5)*6; 
                        positions[i+1] = 100 + (Math.random()-0.5)*6; 
                    }
                }
                volcanoParticles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
